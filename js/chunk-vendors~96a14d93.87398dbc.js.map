{"version":3,"sources":["webpack:///./node_modules/ol/tilegrid/common.js","webpack:///./node_modules/ol/tilegrid.js","webpack:///./node_modules/ol/util.js","webpack:///./node_modules/ol/tilecoord.js","webpack:///./node_modules/ol/size.js","webpack:///./node_modules/ol/style/IconImageCache.js","webpack:///./node_modules/ol/structs/LRUCache.js","webpack:///./node_modules/ol/reproj.js","webpack:///./node_modules/ol/reproj/common.js","webpack:///./node_modules/ol/reproj/Triangulation.js","webpack:///./node_modules/ol/source/common.js","webpack:///./node_modules/ol/reproj/Tile.js","webpack:///./node_modules/ol/source/TileEventType.js","webpack:///./node_modules/ol/source/Source.js","webpack:///./node_modules/ol/source/Tile.js","webpack:///./node_modules/ol/tileurlfunction.js","webpack:///./node_modules/ol/source/UrlTile.js","webpack:///./node_modules/ol/source/TileImage.js","webpack:///./node_modules/ol/source/TileJSON.js","webpack:///./node_modules/ol/source/State.js","webpack:///./node_modules/ol/tilegrid/TileGrid.js","webpack:///./node_modules/ol/sphere.js","webpack:///./node_modules/ol/rotationconstraint.js","webpack:///./node_modules/ol/transform.js","webpack:///./node_modules/ol/resolutionconstraint.js","webpack:///./node_modules/ol/string.js","webpack:///./node_modules/ol/structs/PriorityQueue.js"],"names":["DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE","getForProjection","projection","tileGrid","getDefaultTileGrid","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","opt_maxZoom","opt_tileSize","opt_corner","corner","undefined","TOP_LEFT","resolutions","resolutionsFromExtent","origin","tileSize","createXYZ","opt_options","xyzOptions","getExtent","gridOptions","minZoom","maxZoom","maxResolution","opt_maxResolution","height","width","max","length","Array","pow","half","DEGREES","getMetersPerUnit","abstract","Error","uidCounter_","getUid","obj","ol_uid","String","VERSION","createOrUpdate","x","y","opt_tileCoord","getKeyZXY","getKey","fromKey","key","split","map","Number","hash","withinExtentAndZ","getMinZoom","getMaxZoom","tileRange","getFullTileRange","containsXY","hasArea","size","scale","ratio","opt_size","toSize","isArray","IconImageCache","this","cache_","cacheSize_","maxCacheSize_","prototype","clear","canExpireCache","expire","i","iconImage","hasListener","get","src","crossOrigin","color","set","setSize","maxCacheSize","colorString","shared","LRUCache","opt_highWaterMark","highWaterMark","count_","entries_","oldest_","newest_","getCount","containsKey","hasOwnProperty","forEach","f","entry","value_","key_","newer","older","remove","getKeys","keys","getValues","values","peekLast","peekLastKey","peekFirstKey","pop","replace","value","brokenDiagonalRendering_","ERROR_THRESHOLD","ENABLE_RASTER_REPROJECTION","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","opt_destinationResolution","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","addQuad_","leftBound_1","Infinity","triangle","arr","min","source","newTriangle","minX","maxX","bind","addTriangle_","a","b","aSrc","bSrc","cSrc","push","target","d","dSrc","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","isFinite","isNotFinite","centerSrc","dx","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","getTriangles","IMAGE_SMOOTHING_DISABLED","imageSmoothingEnabled","msImageSmoothingEnabled","drawTestTriangle","ctx","u1","v1","u2","v2","beginPath","moveTo","lineTo","closePath","save","clip","fillRect","restore","verifyBrokenDiagonalRendering","data","offset","isBrokenDiagonalRendering","document","createElement","getContext","globalCompositeOperation","fillStyle","getImageData","calculateSourceResolution","targetCenter","targetResolution","sourceCenter","sourceResolution","targetMetersPerUnit","sourceMetersPerUnit","sourceExtent","compensationFactor","calculateSourceExtentResolution","pixelRatio","triangulation","sources","gutter","opt_renderEdges","opt_contextOptions","context","round","canvas","pixelRound","sourceDataExtent","canvasWidthInUnits","canvasHeightInUnits","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","image","drawImage","targetTopLeft","x0","y0","x1","y1","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","steps","ud","vd","step","transform","translate","strokeStyle","lineWidth","stroke","__extends","extendStatics","Object","setPrototypeOf","__proto__","p","call","__","constructor","create","_super","ReprojTile","sourceTileGrid","targetTileGrid","wrappedTileCoord","getTileFunction","opt_errorThreshold","_this","TileState","IDLE","renderEdges_","contextOptions_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","getTileCoordExtent","maxTargetExtent","limitedTargetExtent","state","EMPTY","sourceProjExtent","getResolution","errorThresholdInPixels","triangulation_","getZForResolution","sourceRange","getTileRangeForExtentAndZ","srcX","srcY","minY","maxY","tile","getImage","reproject_","getState","LOADED","ERROR","getTileSize","changed","load","LOADING","leftToLoad_1","sourceListenKey_1","EventType","CHANGE","e","unlistenSources_","setTimeout","Tile","TILELOADSTART","TILELOADEND","TILELOADERROR","Source","options","projection_","attributions_","adaptAttributions","attributions","attributionsCollapsible_","attributionsCollapsible","loading","state_","READY","wrapX_","getAttributions","getAttributionsCollapsible","getProjection","getResolutions","getWrapX","getContextOptions","refresh","setAttributions","setState","attributionLike","frameState","TileSource","opaque_","opaque","tilePixelRatio_","tilePixelRatio","tileCache","TileCache","cacheSize","tmpSize","tileOptions","transition","zDirection","expireCache","usedTiles","getTileCacheForProjection","forEachLoadedTile","callback","tileCoordKey","loaded","covered","getGutterForProjection","setKey","getOpaque","getTile","getTileGrid","getTileGridForProjection","getTilePixelRatio","getTilePixelSize","getTileCoordForTileUrlFunction","opt_projection","updateCacheSize","tileCount","useTile","TileSourceEvent","type","Event","createFromTemplate","template","zRegEx","xRegEx","yRegEx","dashYRegEx","toString","range","getHeight","createFromTemplates","templates","len","tileUrlFunctions","createFromTileUrlFunctions","h","index","expandUrl","url","urls","match","exec","startCharCode","charCodeAt","stopCharCode","charCode","fromCharCode","stop_1","parseInt","UrlTile","generateTileUrlFunction_","tileUrlFunction","tileLoadFunction","setUrls","setUrl","tileLoadingKeys_","getTileLoadFunction","getTileUrlFunction","getPrototypeOf","getUrls","handleTileChange","event","uid","tileState","TileEventType","dispatchEvent","setTileLoadFunction","setTileUrlFunction","pruneExceptNewestZ","join","TileImage","defaultTileLoadFunction","tileClass","ImageTile","tileCacheForProjection","tileGridForProjection","reprojectionErrorThreshold_","reprojectionErrorThreshold","imageSmoothing","renderReprojectionEdges_","usedTileCache","id","getGutter","JSON","stringify","thisProj","projKey","createTile_","urlTileCoord","tileUrl","addEventListener","sourceProjection","cache","newTile","getTileInternal","interimTile","refreshInterimChain","setRenderReprojectionEdges","render","setTileGridForProjection","tilegrid","proj","imageTile","TileJSON","tileJSON_","tileSize_","jsonp","handleTileJSONResponse","handleTileJSONError","client","XMLHttpRequest","onXHRLoad_","onXHRError_","open","send","tileJSON","status","response","parse","responseText","err","getTileJSON","epsg4326Projection","attributionExtent_1","UNDEFINED","tmpTileCoord","TileGrid","zoomFactor","resolutions_","origins","ii","zoomFactor_","origin_","origins_","tileSizes_","tileSizes","extent_","fullTileRanges_","tmpSize_","sizes","restrictedTileRange","calculateTileRanges_","forEachTileCoord","zoom","j","jj","forEachTileCoordParentTileRange","opt_tileRange","opt_extent","tileCoordExtent","floor","getOrigin","getTileCoordChildTileRange","getTileRangeExtent","resolution","getTileCoordForXYAndZ_","getTileCoordForCoordAndResolution","coordinate","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","adjustX","adjustY","xFromOrigin","yFromOrigin","tileCoordX","tileCoordY","getTileCoordResolution","opt_direction","fullTileRanges","DEFAULT_RADIUS","getDistance","c1","c2","opt_radius","radius","lat1","lat2","deltaLatBy2","deltaLonBy2","sin","cos","atan2","sqrt","distance","bearing","lon1","dByR","lat","asin","lon","disable","rotation","none","createSnapToN","n","theta","PI","opt_isMoving","createSnapToZero","opt_tolerance","tolerance","apply","compose","dx1","dy1","sx","sy","angle","dx2","dy2","makeInverse","det","determinant","mat","getViewportClampedResolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","getSmoothClampedResolution","minResolution","result","log","createSnapToResolutions","opt_smooth","opt_maxExtent","opt_showFullExtent","direction","cappedMaxRes","smooth","capped","createSnapToPower","power","opt_minResolution","minZoomLevel","cappedZoomLevel","zoomLevel","newResolution","createMinMaxResolution","padNumber","number","opt_precision","numberString","toFixed","decimal","indexOf","DROP","PriorityQueue","priorityFunction","keyFunction","priorityFunction_","keyFunction_","elements_","priorities_","queuedElements_","dequeue","elements","priorities","element","siftUp_","elementKey","enqueue","priority","siftDown_","getLeftChildIndex_","getRightChildIndex_","getParentIndex_","heapify_","isEmpty","isKeyQueued","isQueued","count","startIndex","lIndex","rIndex","smallerChildIndex","parentIndex","reprioritize"],"mappings":"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","file":"js/chunk-vendors~96a14d93.87398dbc.js","sourcesContent":["/**\n * @module ol/tilegrid/common\n */\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport var DEFAULT_MAX_ZOOM = 42;\n/**\n * Default tile size.\n * @type {number}\n */\nexport var DEFAULT_TILE_SIZE = 256;\n//# sourceMappingURL=common.js.map","/**\n * @module ol/tilegrid\n */\nimport Corner from './extent/Corner.js';\nimport TileGrid from './tilegrid/TileGrid.js';\nimport Units from './proj/Units.js';\nimport { DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE } from './tilegrid/common.js';\nimport { METERS_PER_UNIT, get as getProjection } from './proj.js';\nimport { containsCoordinate, createOrUpdate, getCorner, getHeight, getWidth, } from './extent.js';\nimport { toSize } from './size.js';\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n    var tileGrid = projection.getDefaultTileGrid();\n    if (!tileGrid) {\n        tileGrid = createForProjection(projection);\n        projection.setDefaultTileGrid(tileGrid);\n    }\n    return tileGrid;\n}\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n    var z = tileCoord[0];\n    var center = tileGrid.getTileCoordCenter(tileCoord);\n    var projectionExtent = extentFromProjection(projection);\n    if (!containsCoordinate(projectionExtent, center)) {\n        var worldWidth = getWidth(projectionExtent);\n        var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n        center[0] += worldWidth * worldsAway;\n        return tileGrid.getTileCoordForCoordAndZ(center, z);\n    }\n    else {\n        return tileCoord;\n    }\n}\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default=} opt_corner Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n    var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n    var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n    return new TileGrid({\n        extent: extent,\n        origin: getCorner(extent, corner),\n        resolutions: resolutions,\n        tileSize: opt_tileSize,\n    });\n}\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions=} opt_options Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n    var xyzOptions = opt_options || {};\n    var extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n    var gridOptions = {\n        extent: extent,\n        minZoom: xyzOptions.minZoom,\n        tileSize: xyzOptions.tileSize,\n        resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution),\n    };\n    return new TileGrid(gridOptions);\n}\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number=} opt_maxResolution Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {\n    var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;\n    var height = getHeight(extent);\n    var width = getWidth(extent);\n    var tileSize = toSize(opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE);\n    var maxResolution = opt_maxResolution > 0\n        ? opt_maxResolution\n        : Math.max(width / tileSize[0], height / tileSize[1]);\n    var length = maxZoom + 1;\n    var resolutions = new Array(length);\n    for (var z = 0; z < length; ++z) {\n        resolutions[z] = maxResolution / Math.pow(2, z);\n    }\n    return resolutions;\n}\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent/Corner.js\").default=} opt_corner Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n    var extent = extentFromProjection(projection);\n    return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n    projection = getProjection(projection);\n    var extent = projection.getExtent();\n    if (!extent) {\n        var half = (180 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit();\n        extent = createOrUpdate(-half, -half, half, half);\n    }\n    return extent;\n}\n//# sourceMappingURL=tilegrid.js.map","/**\n * @module ol/util\n */\n/**\n * @return {?} Any return.\n */\nexport function abstract() {\n    return /** @type {?} */ ((function () {\n        throw new Error('Unimplemented abstract method.');\n    })());\n}\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\nvar uidCounter_ = 0;\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {string} The unique ID for the object.\n * @api\n */\nexport function getUid(obj) {\n    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\n/**\n * OpenLayers version.\n * @type {string}\n */\nexport var VERSION = '6.5.0';\n//# sourceMappingURL=util.js.map","/**\n * @module ol/tilecoord\n */\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord=} opt_tileCoord Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\n    if (opt_tileCoord !== undefined) {\n        opt_tileCoord[0] = z;\n        opt_tileCoord[1] = x;\n        opt_tileCoord[2] = y;\n        return opt_tileCoord;\n    }\n    else {\n        return [z, x, y];\n    }\n}\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n    return z + '/' + x + '/' + y;\n}\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n    return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n    return key.split('/').map(Number);\n}\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n    var z = tileCoord[0];\n    var x = tileCoord[1];\n    var y = tileCoord[2];\n    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n        return false;\n    }\n    var tileRange = tileGrid.getFullTileRange(z);\n    if (!tileRange) {\n        return true;\n    }\n    else {\n        return tileRange.containsXY(x, y);\n    }\n}\n//# sourceMappingURL=tilecoord.js.map","/**\n * @module ol/size\n */\n/**\n * An array of numbers representing a size: `[width, height]`.\n * @typedef {Array<number>} Size\n * @api\n */\n/**\n * Returns a buffered size.\n * @param {Size} size Size.\n * @param {number} num The amount by which to buffer.\n * @param {Size=} opt_size Optional reusable size array.\n * @return {Size} The buffered size.\n */\nexport function buffer(size, num, opt_size) {\n    if (opt_size === undefined) {\n        opt_size = [0, 0];\n    }\n    opt_size[0] = size[0] + 2 * num;\n    opt_size[1] = size[1] + 2 * num;\n    return opt_size;\n}\n/**\n * Determines if a size has a positive area.\n * @param {Size} size The size to test.\n * @return {boolean} The size has a positive area.\n */\nexport function hasArea(size) {\n    return size[0] > 0 && size[1] > 0;\n}\n/**\n * Returns a size scaled by a ratio. The result will be an array of integers.\n * @param {Size} size Size.\n * @param {number} ratio Ratio.\n * @param {Size=} opt_size Optional reusable size array.\n * @return {Size} The scaled size.\n */\nexport function scale(size, ratio, opt_size) {\n    if (opt_size === undefined) {\n        opt_size = [0, 0];\n    }\n    opt_size[0] = (size[0] * ratio + 0.5) | 0;\n    opt_size[1] = (size[1] * ratio + 0.5) | 0;\n    return opt_size;\n}\n/**\n * Returns an `Size` array for the passed in number (meaning: square) or\n * `Size` array.\n * (meaning: non-square),\n * @param {number|Size} size Width and height.\n * @param {Size=} opt_size Optional reusable size array.\n * @return {Size} Size.\n * @api\n */\nexport function toSize(size, opt_size) {\n    if (Array.isArray(size)) {\n        return size;\n    }\n    else {\n        if (opt_size === undefined) {\n            opt_size = [size, size];\n        }\n        else {\n            opt_size[0] = size;\n            opt_size[1] = size;\n        }\n        return opt_size;\n    }\n}\n//# sourceMappingURL=size.js.map","/**\n * @module ol/style/IconImageCache\n */\nimport { asString } from '../color.js';\n/**\n * @classdesc\n * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.\n */\nvar IconImageCache = /** @class */ (function () {\n    function IconImageCache() {\n        /**\n         * @type {!Object<string, import(\"./IconImage.js\").default>}\n         * @private\n         */\n        this.cache_ = {};\n        /**\n         * @type {number}\n         * @private\n         */\n        this.cacheSize_ = 0;\n        /**\n         * @type {number}\n         * @private\n         */\n        this.maxCacheSize_ = 32;\n    }\n    /**\n     * FIXME empty description for jsdoc\n     */\n    IconImageCache.prototype.clear = function () {\n        this.cache_ = {};\n        this.cacheSize_ = 0;\n    };\n    /**\n     * @return {boolean} Can expire cache.\n     */\n    IconImageCache.prototype.canExpireCache = function () {\n        return this.cacheSize_ > this.maxCacheSize_;\n    };\n    /**\n     * FIXME empty description for jsdoc\n     */\n    IconImageCache.prototype.expire = function () {\n        if (this.canExpireCache()) {\n            var i = 0;\n            for (var key in this.cache_) {\n                var iconImage = this.cache_[key];\n                if ((i++ & 3) === 0 && !iconImage.hasListener()) {\n                    delete this.cache_[key];\n                    --this.cacheSize_;\n                }\n            }\n        }\n    };\n    /**\n     * @param {string} src Src.\n     * @param {?string} crossOrigin Cross origin.\n     * @param {import(\"../color.js\").Color} color Color.\n     * @return {import(\"./IconImage.js\").default} Icon image.\n     */\n    IconImageCache.prototype.get = function (src, crossOrigin, color) {\n        var key = getKey(src, crossOrigin, color);\n        return key in this.cache_ ? this.cache_[key] : null;\n    };\n    /**\n     * @param {string} src Src.\n     * @param {?string} crossOrigin Cross origin.\n     * @param {import(\"../color.js\").Color} color Color.\n     * @param {import(\"./IconImage.js\").default} iconImage Icon image.\n     */\n    IconImageCache.prototype.set = function (src, crossOrigin, color, iconImage) {\n        var key = getKey(src, crossOrigin, color);\n        this.cache_[key] = iconImage;\n        ++this.cacheSize_;\n    };\n    /**\n     * Set the cache size of the icon cache. Default is `32`. Change this value when\n     * your map uses more than 32 different icon images and you are not caching icon\n     * styles on the application level.\n     * @param {number} maxCacheSize Cache max size.\n     * @api\n     */\n    IconImageCache.prototype.setSize = function (maxCacheSize) {\n        this.maxCacheSize_ = maxCacheSize;\n        this.expire();\n    };\n    return IconImageCache;\n}());\n/**\n * @param {string} src Src.\n * @param {?string} crossOrigin Cross origin.\n * @param {import(\"../color.js\").Color} color Color.\n * @return {string} Cache key.\n */\nfunction getKey(src, crossOrigin, color) {\n    var colorString = color ? asString(color) : 'null';\n    return crossOrigin + ':' + src + ':' + colorString;\n}\nexport default IconImageCache;\n/**\n * The {@link module:ol/style/IconImageCache~IconImageCache} for\n * {@link module:ol/style/Icon~Icon} images.\n * @api\n */\nexport var shared = new IconImageCache();\n//# sourceMappingURL=IconImageCache.js.map","/**\n * @module ol/structs/LRUCache\n */\nimport { assert } from '../asserts.js';\n/**\n * @typedef {Object} Entry\n * @property {string} key_\n * @property {Object} newer\n * @property {Object} older\n * @property {*} value_\n */\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nvar LRUCache = /** @class */ (function () {\n    /**\n     * @param {number=} opt_highWaterMark High water mark.\n     */\n    function LRUCache(opt_highWaterMark) {\n        /**\n         * Desired max cache size after expireCache(). If set to 0, no cache entries\n         * will be pruned at all.\n         * @type {number}\n         */\n        this.highWaterMark =\n            opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.count_ = 0;\n        /**\n         * @private\n         * @type {!Object<string, Entry>}\n         */\n        this.entries_ = {};\n        /**\n         * @private\n         * @type {?Entry}\n         */\n        this.oldest_ = null;\n        /**\n         * @private\n         * @type {?Entry}\n         */\n        this.newest_ = null;\n    }\n    /**\n     * @return {boolean} Can expire cache.\n     */\n    LRUCache.prototype.canExpireCache = function () {\n        return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n    };\n    /**\n     * FIXME empty description for jsdoc\n     */\n    LRUCache.prototype.clear = function () {\n        this.count_ = 0;\n        this.entries_ = {};\n        this.oldest_ = null;\n        this.newest_ = null;\n    };\n    /**\n     * @param {string} key Key.\n     * @return {boolean} Contains key.\n     */\n    LRUCache.prototype.containsKey = function (key) {\n        return this.entries_.hasOwnProperty(key);\n    };\n    /**\n     * @param {function(T, string, LRUCache<T>): ?} f The function\n     *     to call for every entry from the oldest to the newer. This function takes\n     *     3 arguments (the entry value, the entry key and the LRUCache object).\n     *     The return value is ignored.\n     */\n    LRUCache.prototype.forEach = function (f) {\n        var entry = this.oldest_;\n        while (entry) {\n            f(entry.value_, entry.key_, this);\n            entry = entry.newer;\n        }\n    };\n    /**\n     * @param {string} key Key.\n     * @param {*=} opt_options Options (reserverd for subclasses).\n     * @return {T} Value.\n     */\n    LRUCache.prototype.get = function (key, opt_options) {\n        var entry = this.entries_[key];\n        assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n        if (entry === this.newest_) {\n            return entry.value_;\n        }\n        else if (entry === this.oldest_) {\n            this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n            this.oldest_.older = null;\n        }\n        else {\n            entry.newer.older = entry.older;\n            entry.older.newer = entry.newer;\n        }\n        entry.newer = null;\n        entry.older = this.newest_;\n        this.newest_.newer = entry;\n        this.newest_ = entry;\n        return entry.value_;\n    };\n    /**\n     * Remove an entry from the cache.\n     * @param {string} key The entry key.\n     * @return {T} The removed entry.\n     */\n    LRUCache.prototype.remove = function (key) {\n        var entry = this.entries_[key];\n        assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n        if (entry === this.newest_) {\n            this.newest_ = /** @type {Entry} */ (entry.older);\n            if (this.newest_) {\n                this.newest_.newer = null;\n            }\n        }\n        else if (entry === this.oldest_) {\n            this.oldest_ = /** @type {Entry} */ (entry.newer);\n            if (this.oldest_) {\n                this.oldest_.older = null;\n            }\n        }\n        else {\n            entry.newer.older = entry.older;\n            entry.older.newer = entry.newer;\n        }\n        delete this.entries_[key];\n        --this.count_;\n        return entry.value_;\n    };\n    /**\n     * @return {number} Count.\n     */\n    LRUCache.prototype.getCount = function () {\n        return this.count_;\n    };\n    /**\n     * @return {Array<string>} Keys.\n     */\n    LRUCache.prototype.getKeys = function () {\n        var keys = new Array(this.count_);\n        var i = 0;\n        var entry;\n        for (entry = this.newest_; entry; entry = entry.older) {\n            keys[i++] = entry.key_;\n        }\n        return keys;\n    };\n    /**\n     * @return {Array<T>} Values.\n     */\n    LRUCache.prototype.getValues = function () {\n        var values = new Array(this.count_);\n        var i = 0;\n        var entry;\n        for (entry = this.newest_; entry; entry = entry.older) {\n            values[i++] = entry.value_;\n        }\n        return values;\n    };\n    /**\n     * @return {T} Last value.\n     */\n    LRUCache.prototype.peekLast = function () {\n        return this.oldest_.value_;\n    };\n    /**\n     * @return {string} Last key.\n     */\n    LRUCache.prototype.peekLastKey = function () {\n        return this.oldest_.key_;\n    };\n    /**\n     * Get the key of the newest item in the cache.  Throws if the cache is empty.\n     * @return {string} The newest key.\n     */\n    LRUCache.prototype.peekFirstKey = function () {\n        return this.newest_.key_;\n    };\n    /**\n     * @return {T} value Value.\n     */\n    LRUCache.prototype.pop = function () {\n        var entry = this.oldest_;\n        delete this.entries_[entry.key_];\n        if (entry.newer) {\n            entry.newer.older = null;\n        }\n        this.oldest_ = /** @type {Entry} */ (entry.newer);\n        if (!this.oldest_) {\n            this.newest_ = null;\n        }\n        --this.count_;\n        return entry.value_;\n    };\n    /**\n     * @param {string} key Key.\n     * @param {T} value Value.\n     */\n    LRUCache.prototype.replace = function (key, value) {\n        this.get(key); // update `newest_`\n        this.entries_[key].value_ = value;\n    };\n    /**\n     * @param {string} key Key.\n     * @param {T} value Value.\n     */\n    LRUCache.prototype.set = function (key, value) {\n        assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n        var entry = {\n            key_: key,\n            newer: null,\n            older: this.newest_,\n            value_: value,\n        };\n        if (!this.newest_) {\n            this.oldest_ = entry;\n        }\n        else {\n            this.newest_.newer = entry;\n        }\n        this.newest_ = entry;\n        this.entries_[key] = entry;\n        ++this.count_;\n    };\n    /**\n     * Set a maximum number of entries for the cache.\n     * @param {number} size Cache size.\n     * @api\n     */\n    LRUCache.prototype.setSize = function (size) {\n        this.highWaterMark = size;\n    };\n    return LRUCache;\n}());\nexport default LRUCache;\n//# sourceMappingURL=LRUCache.js.map","/**\n * @module ol/reproj\n */\nimport { IMAGE_SMOOTHING_DISABLED } from './source/common.js';\nimport { assign } from './obj.js';\nimport { containsCoordinate, createEmpty, extend, forEachCorner, getCenter, getHeight, getTopLeft, getWidth, } from './extent.js';\nimport { createCanvasContext2D } from './dom.js';\nimport { getPointResolution, transform } from './proj.js';\nimport { solveLinearSystem } from './math.js';\nvar brokenDiagonalRendering_;\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(u1, v1);\n    ctx.lineTo(u2, v2);\n    ctx.closePath();\n    ctx.save();\n    ctx.clip();\n    ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n    ctx.restore();\n}\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n    // the values ought to be close to the rgba(210, 0, 0, 0.75)\n    return (Math.abs(data[offset * 4] - 210) > 2 ||\n        Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2);\n}\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n    if (brokenDiagonalRendering_ === undefined) {\n        var ctx = document.createElement('canvas').getContext('2d');\n        ctx.globalCompositeOperation = 'lighter';\n        ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n        drawTestTriangle(ctx, 4, 5, 4, 0);\n        drawTestTriangle(ctx, 4, 5, 0, 5);\n        var data = ctx.getImageData(0, 0, 3, 3).data;\n        brokenDiagonalRendering_ =\n            verifyBrokenDiagonalRendering(data, 0) ||\n                verifyBrokenDiagonalRendering(data, 4) ||\n                verifyBrokenDiagonalRendering(data, 8);\n    }\n    return brokenDiagonalRendering_;\n}\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n    var sourceCenter = transform(targetCenter, targetProj, sourceProj);\n    // calculate the ideal resolution of the source data\n    var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n    var targetMetersPerUnit = targetProj.getMetersPerUnit();\n    if (targetMetersPerUnit !== undefined) {\n        sourceResolution *= targetMetersPerUnit;\n    }\n    var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n    if (sourceMetersPerUnit !== undefined) {\n        sourceResolution /= sourceMetersPerUnit;\n    }\n    // Based on the projection properties, the point resolution at the specified\n    // coordinates may be slightly different. We need to reverse-compensate this\n    // in order to achieve optimal results.\n    var sourceExtent = sourceProj.getExtent();\n    if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n        var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n            sourceResolution;\n        if (isFinite(compensationFactor) && compensationFactor > 0) {\n            sourceResolution /= compensationFactor;\n        }\n    }\n    return sourceResolution;\n}\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {\n    var targetCenter = getCenter(targetExtent);\n    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n        forEachCorner(targetExtent, function (corner) {\n            sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);\n            return isFinite(sourceResolution) && sourceResolution > 0;\n        });\n    }\n    return sourceResolution;\n}\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation\n * Calculated triangulation.\n * @param {Array<{extent: import(\"./extent.js\").Extent,\n *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n * Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @param {object=} opt_contextOptions Properties to set on the canvas context.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_contextOptions) {\n    var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));\n    assign(context, opt_contextOptions);\n    if (sources.length === 0) {\n        return context.canvas;\n    }\n    context.scale(pixelRatio, pixelRatio);\n    function pixelRound(value) {\n        return Math.round(value * pixelRatio) / pixelRatio;\n    }\n    context.globalCompositeOperation = 'lighter';\n    var sourceDataExtent = createEmpty();\n    sources.forEach(function (src, i, arr) {\n        extend(sourceDataExtent, src.extent);\n    });\n    var canvasWidthInUnits = getWidth(sourceDataExtent);\n    var canvasHeightInUnits = getHeight(sourceDataExtent);\n    var stitchContext = createCanvasContext2D(Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution), Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution));\n    assign(stitchContext, opt_contextOptions);\n    var stitchScale = pixelRatio / sourceResolution;\n    sources.forEach(function (src, i, arr) {\n        var xPos = src.extent[0] - sourceDataExtent[0];\n        var yPos = -(src.extent[3] - sourceDataExtent[3]);\n        var srcWidth = getWidth(src.extent);\n        var srcHeight = getHeight(src.extent);\n        // This test should never fail -- but it does. Need to find a fix the upstream condition\n        if (src.image.width > 0 && src.image.height > 0) {\n            stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n        }\n    });\n    var targetTopLeft = getTopLeft(targetExtent);\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n        /* Calculate affine transform (src -> dst)\n         * Resulting matrix can be used to transform coordinate\n         * from `sourceProjection` to destination pixels.\n         *\n         * To optimize number of context calls and increase numerical stability,\n         * we also do the following operations:\n         * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n         * here before solving the linear system so [ui, vi] are pixel coordinates.\n         *\n         * Src points: xi, yi\n         * Dst points: ui, vi\n         * Affine coefficients: aij\n         *\n         * | x0 y0 1  0  0 0 |   |a00|   |u0|\n         * | x1 y1 1  0  0 0 |   |a01|   |u1|\n         * | x2 y2 1  0  0 0 | x |a02| = |u2|\n         * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n         * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n         * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n         */\n        var source = triangle.source;\n        var target = triangle.target;\n        var x0 = source[0][0], y0 = source[0][1];\n        var x1 = source[1][0], y1 = source[1][1];\n        var x2 = source[2][0], y2 = source[2][1];\n        // Make sure that everything is on pixel boundaries\n        var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n        var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);\n        var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n        var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);\n        var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n        var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);\n        // Shift all the source points to improve numerical stability\n        // of all the subsequent calculations. The [x0, y0] is used here.\n        // This is also used to simplify the linear system.\n        var sourceNumericalShiftX = x0;\n        var sourceNumericalShiftY = y0;\n        x0 = 0;\n        y0 = 0;\n        x1 -= sourceNumericalShiftX;\n        y1 -= sourceNumericalShiftY;\n        x2 -= sourceNumericalShiftX;\n        y2 -= sourceNumericalShiftY;\n        var augmentedMatrix = [\n            [x1, y1, 0, 0, u1 - u0],\n            [x2, y2, 0, 0, u2 - u0],\n            [0, 0, x1, y1, v1 - v0],\n            [0, 0, x2, y2, v2 - v0],\n        ];\n        var affineCoefs = solveLinearSystem(augmentedMatrix);\n        if (!affineCoefs) {\n            return;\n        }\n        context.save();\n        context.beginPath();\n        if (isBrokenDiagonalRendering() ||\n            opt_contextOptions === IMAGE_SMOOTHING_DISABLED) {\n            // Make sure that all lines are horizontal or vertical\n            context.moveTo(u1, v1);\n            // This is the diagonal line. Do it in 4 steps\n            var steps = 4;\n            var ud = u0 - u1;\n            var vd = v0 - v1;\n            for (var step = 0; step < steps; step++) {\n                // Go horizontally\n                context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound((step * vd) / (steps - 1)));\n                // Go vertically\n                if (step != steps - 1) {\n                    context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound(((step + 1) * vd) / (steps - 1)));\n                }\n            }\n            // We are almost at u0r, v0r\n            context.lineTo(u2, v2);\n        }\n        else {\n            context.moveTo(u1, v1);\n            context.lineTo(u0, v0);\n            context.lineTo(u2, v2);\n        }\n        context.clip();\n        context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n        context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n        context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n        context.drawImage(stitchContext.canvas, 0, 0);\n        context.restore();\n    });\n    if (opt_renderEdges) {\n        context.save();\n        context.globalCompositeOperation = 'source-over';\n        context.strokeStyle = 'black';\n        context.lineWidth = 1;\n        triangulation.getTriangles().forEach(function (triangle, i, arr) {\n            var target = triangle.target;\n            var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n            var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n            var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n            var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n            var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n            var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n            context.beginPath();\n            context.moveTo(u1, v1);\n            context.lineTo(u0, v0);\n            context.lineTo(u2, v2);\n            context.closePath();\n            context.stroke();\n        });\n        context.restore();\n    }\n    return context.canvas;\n}\n//# sourceMappingURL=reproj.js.map","/**\n * @module ol/reproj/common\n */\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport var ERROR_THRESHOLD = 0.5;\n/**\n * Enable automatic reprojection of raster sources. Default is `true`.\n * TODO: decide if we want to expose this as a build flag or remove it\n * @type {boolean}\n */\nexport var ENABLE_RASTER_REPROJECTION = true;\n//# sourceMappingURL=common.js.map","/**\n * @module ol/reproj/Triangulation\n */\nimport { boundingExtent, createEmpty, extendCoordinate, getArea, getBottomLeft, getBottomRight, getTopLeft, getTopRight, getWidth, intersects, } from '../extent.js';\nimport { getTransform } from '../proj.js';\nimport { log2, modulo } from '../math.js';\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target\n */\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nvar MAX_SUBDIVISION = 10;\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nvar MAX_TRIANGLE_WIDTH = 0.25;\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nvar Triangulation = /** @class */ (function () {\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n     * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n     * @param {number} errorThreshold Acceptable error (in source units).\n     * @param {?number} opt_destinationResolution The (optional) resolution of the destination.\n     */\n    function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         * @private\n         */\n        this.sourceProj_ = sourceProj;\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         * @private\n         */\n        this.targetProj_ = targetProj;\n        /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n        var transformInvCache = {};\n        var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n        /**\n         * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n         * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n         * @private\n         */\n        this.transformInv_ = function (c) {\n            var key = c[0] + '/' + c[1];\n            if (!transformInvCache[key]) {\n                transformInvCache[key] = transformInv(c);\n            }\n            return transformInvCache[key];\n        };\n        /**\n         * @type {import(\"../extent.js\").Extent}\n         * @private\n         */\n        this.maxSourceExtent_ = maxSourceExtent;\n        /**\n         * @type {number}\n         * @private\n         */\n        this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n        /**\n         * @type {Array<Triangle>}\n         * @private\n         */\n        this.triangles_ = [];\n        /**\n         * Indicates that the triangulation crosses edge of the source projection.\n         * @type {boolean}\n         * @private\n         */\n        this.wrapsXInSource_ = false;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.canWrapXInSource_ =\n            this.sourceProj_.canWrapX() &&\n                !!maxSourceExtent &&\n                !!this.sourceProj_.getExtent() &&\n                getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());\n        /**\n         * @type {?number}\n         * @private\n         */\n        this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n            ? getWidth(this.sourceProj_.getExtent())\n            : null;\n        /**\n         * @type {?number}\n         * @private\n         */\n        this.targetWorldWidth_ = this.targetProj_.getExtent()\n            ? getWidth(this.targetProj_.getExtent())\n            : null;\n        var destinationTopLeft = getTopLeft(targetExtent);\n        var destinationTopRight = getTopRight(targetExtent);\n        var destinationBottomRight = getBottomRight(targetExtent);\n        var destinationBottomLeft = getBottomLeft(targetExtent);\n        var sourceTopLeft = this.transformInv_(destinationTopLeft);\n        var sourceTopRight = this.transformInv_(destinationTopRight);\n        var sourceBottomRight = this.transformInv_(destinationBottomRight);\n        var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n        /*\n         * The maxSubdivision controls how many splittings of the target area can\n         * be done. The idea here is to do a linear mapping of the target areas\n         * but the actual overal reprojection (can be) extremely non-linear. The\n         * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n         * tile size. However this function is also called to remap canvas rendered\n         * layers which can be much larger. This calculation increases the maxSubdivision\n         * value by the right factor so that each 256x256 pixel area has\n         * MAX_SUBDIVISION divisions.\n         */\n        var maxSubdivision = MAX_SUBDIVISION +\n            (opt_destinationResolution\n                ? Math.max(0, Math.ceil(log2(getArea(targetExtent) /\n                    (opt_destinationResolution *\n                        opt_destinationResolution *\n                        256 *\n                        256))))\n                : 0);\n        this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);\n        if (this.wrapsXInSource_) {\n            var leftBound_1 = Infinity;\n            this.triangles_.forEach(function (triangle, i, arr) {\n                leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n            });\n            // Shift triangles to be as close to `leftBound` as possible\n            // (if the distance is more than `worldWidth / 2` it can be closer.\n            this.triangles_.forEach(function (triangle) {\n                if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) -\n                    leftBound_1 >\n                    this.sourceWorldWidth_ / 2) {\n                    var newTriangle = [\n                        [triangle.source[0][0], triangle.source[0][1]],\n                        [triangle.source[1][0], triangle.source[1][1]],\n                        [triangle.source[2][0], triangle.source[2][1]],\n                    ];\n                    if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[0][0] -= this.sourceWorldWidth_;\n                    }\n                    if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[1][0] -= this.sourceWorldWidth_;\n                    }\n                    if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {\n                        newTriangle[2][0] -= this.sourceWorldWidth_;\n                    }\n                    // Rarely (if the extent contains both the dateline and prime meridian)\n                    // the shift can in turn break some triangles.\n                    // Detect this here and don't shift in such cases.\n                    var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n                    var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n                    if (maxX - minX < this.sourceWorldWidth_ / 2) {\n                        triangle.source = newTriangle;\n                    }\n                }\n            }.bind(this));\n        }\n        transformInvCache = {};\n    }\n    /**\n     * Adds triangle to the triangulation.\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @private\n     */\n    Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {\n        this.triangles_.push({\n            source: [aSrc, bSrc, cSrc],\n            target: [a, b, c],\n        });\n    };\n    /**\n     * Adds quad (points in clock-wise order) to the triangulation\n     * (and reprojects the vertices) if valid.\n     * Performs quad subdivision if needed to increase precision.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n     * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n     * @private\n     */\n    Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n        var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n        var sourceCoverageX = this.sourceWorldWidth_\n            ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n            : null;\n        var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n        // when the quad is wrapped in the source projection\n        // it covers most of the projection extent, but not fully\n        var wrapsX = this.sourceProj_.canWrapX() &&\n            sourceCoverageX > 0.5 &&\n            sourceCoverageX < 1;\n        var needsSubdivision = false;\n        if (maxSubdivision > 0) {\n            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n                var targetQuadExtent = boundingExtent([a, b, c, d]);\n                var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n                needsSubdivision =\n                    targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n            }\n            if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n                needsSubdivision =\n                    sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n            }\n        }\n        if (!needsSubdivision && this.maxSourceExtent_) {\n            if (isFinite(sourceQuadExtent[0]) &&\n                isFinite(sourceQuadExtent[1]) &&\n                isFinite(sourceQuadExtent[2]) &&\n                isFinite(sourceQuadExtent[3])) {\n                if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n                    // whole quad outside source projection extent -> ignore\n                    return;\n                }\n            }\n        }\n        var isNotFinite = 0;\n        if (!needsSubdivision) {\n            if (!isFinite(aSrc[0]) ||\n                !isFinite(aSrc[1]) ||\n                !isFinite(bSrc[0]) ||\n                !isFinite(bSrc[1]) ||\n                !isFinite(cSrc[0]) ||\n                !isFinite(cSrc[1]) ||\n                !isFinite(dSrc[0]) ||\n                !isFinite(dSrc[1])) {\n                if (maxSubdivision > 0) {\n                    needsSubdivision = true;\n                }\n                else {\n                    // It might be the case that only 1 of the points is infinite. In this case\n                    // we can draw a single triangle with the other three points\n                    isNotFinite =\n                        (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n                            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n                            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n                            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n                    if (isNotFinite != 1 &&\n                        isNotFinite != 2 &&\n                        isNotFinite != 4 &&\n                        isNotFinite != 8) {\n                        return;\n                    }\n                }\n            }\n        }\n        if (maxSubdivision > 0) {\n            if (!needsSubdivision) {\n                var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n                var centerSrc = this.transformInv_(center);\n                var dx = void 0;\n                if (wrapsX) {\n                    var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) +\n                        modulo(cSrc[0], sourceWorldWidth)) /\n                        2;\n                    dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n                }\n                else {\n                    dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n                }\n                var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n                var centerSrcErrorSquared = dx * dx + dy * dy;\n                needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n            }\n            if (needsSubdivision) {\n                if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n                    // split horizontally (top & bottom)\n                    var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n                    var bcSrc = this.transformInv_(bc);\n                    var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n                    var daSrc = this.transformInv_(da);\n                    this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n                    this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n                }\n                else {\n                    // split vertically (left & right)\n                    var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n                    var abSrc = this.transformInv_(ab);\n                    var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n                    var cdSrc = this.transformInv_(cd);\n                    this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n                    this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n                }\n                return;\n            }\n        }\n        if (wrapsX) {\n            if (!this.canWrapXInSource_) {\n                return;\n            }\n            this.wrapsXInSource_ = true;\n        }\n        // Exactly zero or one of *Src is not finite\n        // The triangles must have the diagonal line as the first side\n        // This is to allow easy code in reproj.s to make it straight for broken\n        // browsers that can't handle diagonal clipping\n        if ((isNotFinite & 0xb) == 0) {\n            this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n        }\n        if ((isNotFinite & 0xe) == 0) {\n            this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n        }\n        if (isNotFinite) {\n            // Try the other two triangles\n            if ((isNotFinite & 0xd) == 0) {\n                this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n            }\n            if ((isNotFinite & 0x7) == 0) {\n                this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n            }\n        }\n    };\n    /**\n     * Calculates extent of the 'source' coordinates from all the triangles.\n     *\n     * @return {import(\"../extent.js\").Extent} Calculated extent.\n     */\n    Triangulation.prototype.calculateSourceExtent = function () {\n        var extent = createEmpty();\n        this.triangles_.forEach(function (triangle, i, arr) {\n            var src = triangle.source;\n            extendCoordinate(extent, src[0]);\n            extendCoordinate(extent, src[1]);\n            extendCoordinate(extent, src[2]);\n        });\n        return extent;\n    };\n    /**\n     * @return {Array<Triangle>} Array of the calculated triangles.\n     */\n    Triangulation.prototype.getTriangles = function () {\n        return this.triangles_;\n    };\n    return Triangulation;\n}());\nexport default Triangulation;\n//# sourceMappingURL=Triangulation.js.map","/**\n * @module ol/source/common\n */\n/**\n * Default WMS version.\n * @type {string}\n */\nexport var DEFAULT_WMS_VERSION = '1.3.0';\n/**\n * Context options to disable image smoothing.\n * @type {Object}\n */\nexport var IMAGE_SMOOTHING_DISABLED = {\n    imageSmoothingEnabled: false,\n    msImageSmoothingEnabled: false,\n};\n//# sourceMappingURL=common.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport { calculateSourceExtentResolution, render as renderReprojected, } from '../reproj.js';\nimport { clamp } from '../math.js';\nimport { getArea, getIntersection } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /** @class */ (function (_super) {\n    __extends(ReprojTile, _super);\n    /**\n     * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n     * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n     * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {number} gutter Gutter of the source tiles.\n     * @param {FunctionType} getTileFunction\n     *     Function returning source tiles (z, x, y, pixelRatio).\n     * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n     * @param {boolean=} opt_renderEdges Render reprojection edges.\n     * @param {object=} opt_contextOptions Properties to set on the canvas context.\n     */\n    function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {\n        var _this = _super.call(this, tileCoord, TileState.IDLE) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n        /**\n         * @private\n         * @type {object}\n         */\n        _this.contextOptions_ = opt_contextOptions;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.pixelRatio_ = pixelRatio;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.gutter_ = gutter;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.canvas_ = null;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.sourceTileGrid_ = sourceTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.targetTileGrid_ = targetTileGrid;\n        /**\n         * @private\n         * @type {import(\"../tilecoord.js\").TileCoord}\n         */\n        _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n        /**\n         * @private\n         * @type {!Array<import(\"../Tile.js\").default>}\n         */\n        _this.sourceTiles_ = [];\n        /**\n         * @private\n         * @type {?Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.sourcesListenerKeys_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.sourceZ_ = 0;\n        var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);\n        var maxTargetExtent = _this.targetTileGrid_.getExtent();\n        var maxSourceExtent = _this.sourceTileGrid_.getExtent();\n        var limitedTargetExtent = maxTargetExtent\n            ? getIntersection(targetExtent, maxTargetExtent)\n            : targetExtent;\n        if (getArea(limitedTargetExtent) === 0) {\n            // Tile is completely outside range -> EMPTY\n            // TODO: is it actually correct that the source even creates the tile ?\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var sourceProjExtent = sourceProj.getExtent();\n        if (sourceProjExtent) {\n            if (!maxSourceExtent) {\n                maxSourceExtent = sourceProjExtent;\n            }\n            else {\n                maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n            }\n        }\n        var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);\n        var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);\n        if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n            // invalid sourceResolution -> EMPTY\n            // probably edges of the projections when no extent is defined\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n        /**\n         * @private\n         * @type {!import(\"./Triangulation.js\").default}\n         */\n        _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);\n        if (_this.triangulation_.getTriangles().length === 0) {\n            // no valid triangles -> EMPTY\n            _this.state = TileState.EMPTY;\n            return _this;\n        }\n        _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n        var sourceExtent = _this.triangulation_.calculateSourceExtent();\n        if (maxSourceExtent) {\n            if (sourceProj.canWrapX()) {\n                sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n                sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n            }\n            else {\n                sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n            }\n        }\n        if (!getArea(sourceExtent)) {\n            _this.state = TileState.EMPTY;\n        }\n        else {\n            var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);\n            for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n                for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n                    var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);\n                    if (tile) {\n                        _this.sourceTiles_.push(tile);\n                    }\n                }\n            }\n            if (_this.sourceTiles_.length === 0) {\n                _this.state = TileState.EMPTY;\n            }\n        }\n        return _this;\n    }\n    /**\n     * Get the HTML Canvas element for this tile.\n     * @return {HTMLCanvasElement} Canvas.\n     */\n    ReprojTile.prototype.getImage = function () {\n        return this.canvas_;\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.reproject_ = function () {\n        var sources = [];\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n            if (tile && tile.getState() == TileState.LOADED) {\n                sources.push({\n                    extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n                    image: tile.getImage(),\n                });\n            }\n        }.bind(this));\n        this.sourceTiles_.length = 0;\n        if (sources.length === 0) {\n            this.state = TileState.ERROR;\n        }\n        else {\n            var z = this.wrappedTileCoord_[0];\n            var size = this.targetTileGrid_.getTileSize(z);\n            var width = typeof size === 'number' ? size : size[0];\n            var height = typeof size === 'number' ? size : size[1];\n            var targetResolution = this.targetTileGrid_.getResolution(z);\n            var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n            var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n            this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);\n            this.state = TileState.LOADED;\n        }\n        this.changed();\n    };\n    /**\n     * Load not yet loaded URI.\n     */\n    ReprojTile.prototype.load = function () {\n        if (this.state == TileState.IDLE) {\n            this.state = TileState.LOADING;\n            this.changed();\n            var leftToLoad_1 = 0;\n            this.sourcesListenerKeys_ = [];\n            this.sourceTiles_.forEach(function (tile, i, arr) {\n                var state = tile.getState();\n                if (state == TileState.IDLE || state == TileState.LOADING) {\n                    leftToLoad_1++;\n                    var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {\n                        var state = tile.getState();\n                        if (state == TileState.LOADED ||\n                            state == TileState.ERROR ||\n                            state == TileState.EMPTY) {\n                            unlistenByKey(sourceListenKey_1);\n                            leftToLoad_1--;\n                            if (leftToLoad_1 === 0) {\n                                this.unlistenSources_();\n                                this.reproject_();\n                            }\n                        }\n                    }, this);\n                    this.sourcesListenerKeys_.push(sourceListenKey_1);\n                }\n            }.bind(this));\n            this.sourceTiles_.forEach(function (tile, i, arr) {\n                var state = tile.getState();\n                if (state == TileState.IDLE) {\n                    tile.load();\n                }\n            });\n            if (leftToLoad_1 === 0) {\n                setTimeout(this.reproject_.bind(this), 0);\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    ReprojTile.prototype.unlistenSources_ = function () {\n        this.sourcesListenerKeys_.forEach(unlistenByKey);\n        this.sourcesListenerKeys_ = null;\n    };\n    return ReprojTile;\n}(Tile));\nexport default ReprojTile;\n//# sourceMappingURL=Tile.js.map","/**\n * @module ol/source/TileEventType\n */\n/**\n * @enum {string}\n */\nexport default {\n    /**\n     * Triggered when a tile starts loading.\n     * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n     * @api\n     */\n    TILELOADSTART: 'tileloadstart',\n    /**\n     * Triggered when a tile finishes loading, either when its data is loaded,\n     * or when loading was aborted because the tile is no longer needed.\n     * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n     * @api\n     */\n    TILELOADEND: 'tileloadend',\n    /**\n     * Triggered if tile loading results in an error.\n     * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n     * @api\n     */\n    TILELOADERROR: 'tileloaderror',\n};\n//# sourceMappingURL=TileEventType.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/Source\n */\nimport BaseObject from '../Object.js';\nimport SourceState from './State.js';\nimport { abstract } from '../util.js';\nimport { get as getProjection } from '../proj.js';\n/**\n * A function that returns a string or an array of strings representing source\n * attributions.\n *\n * @typedef {function(import(\"../PluggableMap.js\").FrameState): (string|Array<string>)} Attribution\n */\n/**\n * A type that can be used to provide attribution information for data sources.\n *\n * It represents either\n * * a simple string (e.g. `' Acme Inc.'`)\n * * an array of simple strings (e.g. `[' Acme Inc.', ' Bacme Inc.']`)\n * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})\n *\n * @typedef {string|Array<string>|Attribution} AttributionLike\n */\n/**\n * @typedef {Object} Options\n * @property {AttributionLike} [attributions]\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {import(\"./State.js\").default} [state='ready']\n * @property {boolean} [wrapX=false]\n */\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for {@link module:ol/layer/Layer~Layer} sources.\n *\n * A generic `change` event is triggered when the state of the source changes.\n * @abstract\n * @api\n */\nvar Source = /** @class */ (function (_super) {\n    __extends(Source, _super);\n    /**\n     * @param {Options} options Source options.\n     */\n    function Source(options) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {import(\"../proj/Projection.js\").default}\n         */\n        _this.projection_ = getProjection(options.projection);\n        /**\n         * @private\n         * @type {?Attribution}\n         */\n        _this.attributions_ = adaptAttributions(options.attributions);\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.attributionsCollapsible_ =\n            options.attributionsCollapsible !== undefined\n                ? options.attributionsCollapsible\n                : true;\n        /**\n         * This source is currently loading data. Sources that defer loading to the\n         * map's tile queue never set this to `true`.\n         * @type {boolean}\n         */\n        _this.loading = false;\n        /**\n         * @private\n         * @type {import(\"./State.js\").default}\n         */\n        _this.state_ =\n            options.state !== undefined ? options.state : SourceState.READY;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\n        return _this;\n    }\n    /**\n     * Get the attribution function for the source.\n     * @return {?Attribution} Attribution function.\n     */\n    Source.prototype.getAttributions = function () {\n        return this.attributions_;\n    };\n    /**\n     * @return {boolean} Attributions are collapsible.\n     */\n    Source.prototype.getAttributionsCollapsible = function () {\n        return this.attributionsCollapsible_;\n    };\n    /**\n     * Get the projection of the source.\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     * @api\n     */\n    Source.prototype.getProjection = function () {\n        return this.projection_;\n    };\n    /**\n     * @abstract\n     * @return {Array<number>|undefined} Resolutions.\n     */\n    Source.prototype.getResolutions = function () {\n        return abstract();\n    };\n    /**\n     * Get the state of the source, see {@link module:ol/source/State~State} for possible states.\n     * @return {import(\"./State.js\").default} State.\n     * @api\n     */\n    Source.prototype.getState = function () {\n        return this.state_;\n    };\n    /**\n     * @return {boolean|undefined} Wrap X.\n     */\n    Source.prototype.getWrapX = function () {\n        return this.wrapX_;\n    };\n    /**\n     * @return {Object|undefined} Context options.\n     */\n    Source.prototype.getContextOptions = function () {\n        return undefined;\n    };\n    /**\n     * Refreshes the source. The source will be cleared, and data from the server will be reloaded.\n     * @api\n     */\n    Source.prototype.refresh = function () {\n        this.changed();\n    };\n    /**\n     * Set the attributions of the source.\n     * @param {AttributionLike|undefined} attributions Attributions.\n     *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},\n     *     or `undefined`.\n     * @api\n     */\n    Source.prototype.setAttributions = function (attributions) {\n        this.attributions_ = adaptAttributions(attributions);\n        this.changed();\n    };\n    /**\n     * Set the state of the source.\n     * @param {import(\"./State.js\").default} state State.\n     */\n    Source.prototype.setState = function (state) {\n        this.state_ = state;\n        this.changed();\n    };\n    return Source;\n}(BaseObject));\n/**\n * Turns the attributions option into an attributions function.\n * @param {AttributionLike|undefined} attributionLike The attribution option.\n * @return {?Attribution} An attribution function (or null).\n */\nfunction adaptAttributions(attributionLike) {\n    if (!attributionLike) {\n        return null;\n    }\n    if (Array.isArray(attributionLike)) {\n        return function (frameState) {\n            return attributionLike;\n        };\n    }\n    if (typeof attributionLike === 'function') {\n        return attributionLike;\n    }\n    return function (frameState) {\n        return [attributionLike];\n    };\n}\nexport default Source;\n//# sourceMappingURL=Source.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport { abstract } from '../util.js';\nimport { assert } from '../asserts.js';\nimport { equivalent } from '../proj.js';\nimport { getKeyZXY, withinExtentAndZ } from '../tilecoord.js';\nimport { getForProjection as getTileGridForProjection, wrapX, } from '../tilegrid.js';\nimport { scale as scaleSize, toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions]\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize]\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [tilePixelRatio]\n * @property {import(\"../proj.js\").ProjectionLike} [projection]\n * @property {import(\"./State.js\").default} [state]\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid]\n * @property {boolean} [wrapX=true]\n * @property {number} [transition]\n * @property {string} [key]\n * @property {number} [zDirection=0]\n */\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\nvar TileSource = /** @class */ (function (_super) {\n    __extends(TileSource, _super);\n    /**\n     * @param {Options} options SourceTile source options.\n     */\n    function TileSource(options) {\n        var _this = _super.call(this, {\n            attributions: options.attributions,\n            attributionsCollapsible: options.attributionsCollapsible,\n            projection: options.projection,\n            state: options.state,\n            wrapX: options.wrapX,\n        }) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.tilePixelRatio_ =\n            options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n        /**\n         * @protected\n         * @type {import(\"../tilegrid/TileGrid.js\").default}\n         */\n        _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n        var tileSize = [256, 256];\n        var tileGrid = options.tileGrid;\n        if (tileGrid) {\n            toSize(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);\n        }\n        /**\n         * @protected\n         * @type {import(\"../TileCache.js\").default}\n         */\n        _this.tileCache = new TileCache(options.cacheSize || 0);\n        /**\n         * @protected\n         * @type {import(\"../size.js\").Size}\n         */\n        _this.tmpSize = [0, 0];\n        /**\n         * @private\n         * @type {string}\n         */\n        _this.key_ = options.key || '';\n        /**\n         * @protected\n         * @type {import(\"../Tile.js\").Options}\n         */\n        _this.tileOptions = { transition: options.transition };\n        /**\n         * zDirection hint, read by the renderer. Indicates which resolution should be used\n         * by a renderer if the views resolution does not match any resolution of the tile source.\n         * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n         * will be used. If -1, the nearest higher resolution will be used.\n         * @type {number}\n         */\n        _this.zDirection = options.zDirection ? options.zDirection : 0;\n        return _this;\n    }\n    /**\n     * @return {boolean} Can expire cache.\n     */\n    TileSource.prototype.canExpireCache = function () {\n        return this.tileCache.canExpireCache();\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n    TileSource.prototype.expireCache = function (projection, usedTiles) {\n        var tileCache = this.getTileCacheForProjection(projection);\n        if (tileCache) {\n            tileCache.expireCache(usedTiles);\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {number} z Zoom level.\n     * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n     * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n     *     loaded tile.  If the callback returns `false`, the tile will not be\n     *     considered loaded.\n     * @return {boolean} The tile range is fully covered with loaded tiles.\n     */\n    TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {\n        var tileCache = this.getTileCacheForProjection(projection);\n        if (!tileCache) {\n            return false;\n        }\n        var covered = true;\n        var tile, tileCoordKey, loaded;\n        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n                tileCoordKey = getKeyZXY(z, x, y);\n                loaded = false;\n                if (tileCache.containsKey(tileCoordKey)) {\n                    tile = /** @type {!import(\"../Tile.js\").default} */ (tileCache.get(tileCoordKey));\n                    loaded = tile.getState() === TileState.LOADED;\n                    if (loaded) {\n                        loaded = callback(tile) !== false;\n                    }\n                }\n                if (!loaded) {\n                    covered = false;\n                }\n            }\n        }\n        return covered;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {number} Gutter.\n     */\n    TileSource.prototype.getGutterForProjection = function (projection) {\n        return 0;\n    };\n    /**\n     * Return the key to be used for all tiles in the source.\n     * @return {string} The key for all tiles.\n     * @protected\n     */\n    TileSource.prototype.getKey = function () {\n        return this.key_;\n    };\n    /**\n     * Set the value to be used as the key for all tiles in the source.\n     * @param {string} key The key for tiles.\n     * @protected\n     */\n    TileSource.prototype.setKey = function (key) {\n        if (this.key_ !== key) {\n            this.key_ = key;\n            this.changed();\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {boolean} Opaque.\n     */\n    TileSource.prototype.getOpaque = function (projection) {\n        return this.opaque_;\n    };\n    /**\n     * @return {Array<number>} Resolutions.\n     */\n    TileSource.prototype.getResolutions = function () {\n        return this.tileGrid.getResolutions();\n    };\n    /**\n     * @abstract\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../Tile.js\").default} Tile.\n     */\n    TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        return abstract();\n    };\n    /**\n     * Return the tile grid of the tile source.\n     * @return {import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     * @api\n     */\n    TileSource.prototype.getTileGrid = function () {\n        return this.tileGrid;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     */\n    TileSource.prototype.getTileGridForProjection = function (projection) {\n        if (!this.tileGrid) {\n            return getTileGridForProjection(projection);\n        }\n        else {\n            return this.tileGrid;\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../TileCache.js\").default} Tile cache.\n     * @protected\n     */\n    TileSource.prototype.getTileCacheForProjection = function (projection) {\n        assert(equivalent(this.getProjection(), projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.\n        );\n        return this.tileCache;\n    };\n    /**\n     * Get the tile pixel ratio for this source. Subclasses may override this\n     * method, which is meant to return a supported pixel ratio that matches the\n     * provided `pixelRatio` as close as possible.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {number} Tile pixel ratio.\n     */\n    TileSource.prototype.getTilePixelRatio = function (pixelRatio) {\n        return this.tilePixelRatio_;\n    };\n    /**\n     * @param {number} z Z.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../size.js\").Size} Tile size.\n     */\n    TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n        var tileGrid = this.getTileGridForProjection(projection);\n        var tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n        var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n        if (tilePixelRatio == 1) {\n            return tileSize;\n        }\n        else {\n            return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n        }\n    };\n    /**\n     * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n     * is outside the resolution and extent range of the tile grid, `null` will be\n     * returned.\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../proj/Projection.js\").default=} opt_projection Projection.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n     *     null if no tile URL should be created for the passed `tileCoord`.\n     */\n    TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {\n        var projection = opt_projection !== undefined ? opt_projection : this.getProjection();\n        var tileGrid = this.getTileGridForProjection(projection);\n        if (this.getWrapX() && projection.isGlobal()) {\n            tileCoord = wrapX(tileGrid, tileCoord, projection);\n        }\n        return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n    };\n    /**\n     * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\n     * @api\n     */\n    TileSource.prototype.clear = function () {\n        this.tileCache.clear();\n    };\n    TileSource.prototype.refresh = function () {\n        this.clear();\n        _super.prototype.refresh.call(this);\n    };\n    /**\n     * Increases the cache size if needed\n     * @param {number} tileCount Minimum number of tiles needed.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    TileSource.prototype.updateCacheSize = function (tileCount, projection) {\n        var tileCache = this.getTileCacheForProjection(projection);\n        if (tileCount > tileCache.highWaterMark) {\n            tileCache.highWaterMark = tileCount;\n        }\n    };\n    /**\n     * Marks a tile coord as being used, without triggering a load.\n     * @abstract\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    TileSource.prototype.useTile = function (z, x, y, projection) { };\n    return TileSource;\n}(Source));\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nvar TileSourceEvent = /** @class */ (function (_super) {\n    __extends(TileSourceEvent, _super);\n    /**\n     * @param {string} type Type.\n     * @param {import(\"../Tile.js\").default} tile The tile.\n     */\n    function TileSourceEvent(type, tile) {\n        var _this = _super.call(this, type) || this;\n        /**\n         * The tile related to the event.\n         * @type {import(\"../Tile.js\").default}\n         * @api\n         */\n        _this.tile = tile;\n        return _this;\n    }\n    return TileSourceEvent;\n}(Event));\nexport { TileSourceEvent };\nexport default TileSource;\n//# sourceMappingURL=Tile.js.map","/**\n * @module ol/tileurlfunction\n */\nimport { assert } from './asserts.js';\nimport { modulo } from './math.js';\nimport { hash as tileCoordHash } from './tilecoord.js';\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n    var zRegEx = /\\{z\\}/g;\n    var xRegEx = /\\{x\\}/g;\n    var yRegEx = /\\{y\\}/g;\n    var dashYRegEx = /\\{-y\\}/g;\n    return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n            return undefined;\n        }\n        else {\n            return template\n                .replace(zRegEx, tileCoord[0].toString())\n                .replace(xRegEx, tileCoord[1].toString())\n                .replace(yRegEx, tileCoord[2].toString())\n                .replace(dashYRegEx, function () {\n                var z = tileCoord[0];\n                var range = tileGrid.getFullTileRange(z);\n                assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n                var y = range.getHeight() - tileCoord[2] - 1;\n                return y.toString();\n            });\n        }\n    });\n}\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n    var len = templates.length;\n    var tileUrlFunctions = new Array(len);\n    for (var i = 0; i < len; ++i) {\n        tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n    }\n    return createFromTileUrlFunctions(tileUrlFunctions);\n}\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n    if (tileUrlFunctions.length === 1) {\n        return tileUrlFunctions[0];\n    }\n    return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n        if (!tileCoord) {\n            return undefined;\n        }\n        else {\n            var h = tileCoordHash(tileCoord);\n            var index = modulo(h, tileUrlFunctions.length);\n            return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n        }\n    });\n}\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n}\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n    var urls = [];\n    var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n    if (match) {\n        // char range\n        var startCharCode = match[1].charCodeAt(0);\n        var stopCharCode = match[2].charCodeAt(0);\n        var charCode = void 0;\n        for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n            urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n        }\n        return urls;\n    }\n    match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n    if (match) {\n        // number range\n        var stop_1 = parseInt(match[2], 10);\n        for (var i = parseInt(match[1], 10); i <= stop_1; i++) {\n            urls.push(url.replace(match[0], i.toString()));\n        }\n        return urls;\n    }\n    urls.push(url);\n    return urls;\n}\n//# sourceMappingURL=tileurlfunction.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/UrlTile\n */\nimport TileEventType from './TileEventType.js';\nimport TileSource, { TileSourceEvent } from './Tile.js';\nimport TileState from '../TileState.js';\nimport { createFromTemplates, expandUrl } from '../tileurlfunction.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions]\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize]\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection]\n * @property {import(\"./State.js\").default} [state]\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid]\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction\n * @property {number} [tilePixelRatio]\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction]\n * @property {string} [url]\n * @property {Array<string>} [urls]\n * @property {boolean} [wrapX=true]\n * @property {number} [transition]\n * @property {string} [key]\n * @property {number} [zDirection=0]\n */\n/**\n * @classdesc\n * Base class for sources providing tiles divided into a tile grid over http.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n */\nvar UrlTile = /** @class */ (function (_super) {\n    __extends(UrlTile, _super);\n    /**\n     * @param {Options} options Image tile options.\n     */\n    function UrlTile(options) {\n        var _this = _super.call(this, {\n            attributions: options.attributions,\n            cacheSize: options.cacheSize,\n            opaque: options.opaque,\n            projection: options.projection,\n            state: options.state,\n            tileGrid: options.tileGrid,\n            tilePixelRatio: options.tilePixelRatio,\n            wrapX: options.wrapX,\n            transition: options.transition,\n            key: options.key,\n            attributionsCollapsible: options.attributionsCollapsible,\n            zDirection: options.zDirection,\n        }) || this;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.generateTileUrlFunction_ =\n            _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\n        /**\n         * @protected\n         * @type {import(\"../Tile.js\").LoadFunction}\n         */\n        _this.tileLoadFunction = options.tileLoadFunction;\n        if (options.tileUrlFunction) {\n            _this.tileUrlFunction = options.tileUrlFunction;\n        }\n        /**\n         * @protected\n         * @type {!Array<string>|null}\n         */\n        _this.urls = null;\n        if (options.urls) {\n            _this.setUrls(options.urls);\n        }\n        else if (options.url) {\n            _this.setUrl(options.url);\n        }\n        /**\n         * @private\n         * @type {!Object<string, boolean>}\n         */\n        _this.tileLoadingKeys_ = {};\n        return _this;\n    }\n    /**\n     * Return the tile load function of the source.\n     * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n     * @api\n     */\n    UrlTile.prototype.getTileLoadFunction = function () {\n        return this.tileLoadFunction;\n    };\n    /**\n     * Return the tile URL function of the source.\n     * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n     * @api\n     */\n    UrlTile.prototype.getTileUrlFunction = function () {\n        return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction\n            ? this.tileUrlFunction.bind(this)\n            : this.tileUrlFunction;\n    };\n    /**\n     * Return the URLs used for this source.\n     * When a tileUrlFunction is used instead of url or urls,\n     * null will be returned.\n     * @return {!Array<string>|null} URLs.\n     * @api\n     */\n    UrlTile.prototype.getUrls = function () {\n        return this.urls;\n    };\n    /**\n     * Handle tile change events.\n     * @param {import(\"../events/Event.js\").default} event Event.\n     * @protected\n     */\n    UrlTile.prototype.handleTileChange = function (event) {\n        var tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n        var uid = getUid(tile);\n        var tileState = tile.getState();\n        var type;\n        if (tileState == TileState.LOADING) {\n            this.tileLoadingKeys_[uid] = true;\n            type = TileEventType.TILELOADSTART;\n        }\n        else if (uid in this.tileLoadingKeys_) {\n            delete this.tileLoadingKeys_[uid];\n            type =\n                tileState == TileState.ERROR\n                    ? TileEventType.TILELOADERROR\n                    : tileState == TileState.LOADED\n                        ? TileEventType.TILELOADEND\n                        : undefined;\n        }\n        if (type != undefined) {\n            this.dispatchEvent(new TileSourceEvent(type, tile));\n        }\n    };\n    /**\n     * Set the tile load function of the source.\n     * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n     * @api\n     */\n    UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {\n        this.tileCache.clear();\n        this.tileLoadFunction = tileLoadFunction;\n        this.changed();\n    };\n    /**\n     * Set the tile URL function of the source.\n     * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n     * @param {string=} key Optional new tile key for the source.\n     * @api\n     */\n    UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, key) {\n        this.tileUrlFunction = tileUrlFunction;\n        this.tileCache.pruneExceptNewestZ();\n        if (typeof key !== 'undefined') {\n            this.setKey(key);\n        }\n        else {\n            this.changed();\n        }\n    };\n    /**\n     * Set the URL to use for requests.\n     * @param {string} url URL.\n     * @api\n     */\n    UrlTile.prototype.setUrl = function (url) {\n        var urls = expandUrl(url);\n        this.urls = urls;\n        this.setUrls(urls);\n    };\n    /**\n     * Set the URLs to use for requests.\n     * @param {Array<string>} urls URLs.\n     * @api\n     */\n    UrlTile.prototype.setUrls = function (urls) {\n        this.urls = urls;\n        var key = urls.join('\\n');\n        if (this.generateTileUrlFunction_) {\n            this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n        }\n        else {\n            this.setKey(key);\n        }\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    UrlTile.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {\n        return undefined;\n    };\n    /**\n     * Marks a tile coord as being used, without triggering a load.\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     */\n    UrlTile.prototype.useTile = function (z, x, y) {\n        var tileCoordKey = getKeyZXY(z, x, y);\n        if (this.tileCache.containsKey(tileCoordKey)) {\n            this.tileCache.get(tileCoordKey);\n        }\n    };\n    return UrlTile;\n}(TileSource));\nexport default UrlTile;\n//# sourceMappingURL=UrlTile.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/source/TileImage\n */\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport { ENABLE_RASTER_REPROJECTION } from '../reproj/common.js';\nimport { IMAGE_SMOOTHING_DISABLED } from './common.js';\nimport { equivalent, get as getProjection } from '../proj.js';\nimport { getKey, getKeyZXY } from '../tilecoord.js';\nimport { getForProjection as getTileGridForProjection } from '../tilegrid.js';\nimport { getUid } from '../util.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n * service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n * request out-of-bounds tiles from the server. When set to `false`, only one\n * world will be rendered. When set to `true`, tiles will be requested for one\n * world only, but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [key] Optional tile key for proper cache fetching\n * @property {number} [zDirection=0] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n/**\n * @classdesc\n * Base class for sources providing images divided into a tile grid.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar TileImage = /** @class */ (function (_super) {\n    __extends(TileImage, _super);\n    /**\n     * @param {!Options} options Image tile options.\n     */\n    function TileImage(options) {\n        var _this = _super.call(this, {\n            attributions: options.attributions,\n            cacheSize: options.cacheSize,\n            opaque: options.opaque,\n            projection: options.projection,\n            state: options.state,\n            tileGrid: options.tileGrid,\n            tileLoadFunction: options.tileLoadFunction\n                ? options.tileLoadFunction\n                : defaultTileLoadFunction,\n            tilePixelRatio: options.tilePixelRatio,\n            tileUrlFunction: options.tileUrlFunction,\n            url: options.url,\n            urls: options.urls,\n            wrapX: options.wrapX,\n            transition: options.transition,\n            key: options.key,\n            attributionsCollapsible: options.attributionsCollapsible,\n            zDirection: options.zDirection,\n        }) || this;\n        /**\n         * @protected\n         * @type {?string}\n         */\n        _this.crossOrigin =\n            options.crossOrigin !== undefined ? options.crossOrigin : null;\n        /**\n         * @protected\n         * @type {typeof ImageTile}\n         */\n        _this.tileClass =\n            options.tileClass !== undefined ? options.tileClass : ImageTile;\n        /**\n         * @protected\n         * @type {!Object<string, TileCache>}\n         */\n        _this.tileCacheForProjection = {};\n        /**\n         * @protected\n         * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n         */\n        _this.tileGridForProjection = {};\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n        /**\n         * @private\n         * @type {object|undefined}\n         */\n        _this.contextOptions_ =\n            options.imageSmoothing === false ? IMAGE_SMOOTHING_DISABLED : undefined;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.renderReprojectionEdges_ = false;\n        return _this;\n    }\n    /**\n     * @return {boolean} Can expire cache.\n     */\n    TileImage.prototype.canExpireCache = function () {\n        if (!ENABLE_RASTER_REPROJECTION) {\n            return _super.prototype.canExpireCache.call(this);\n        }\n        if (this.tileCache.canExpireCache()) {\n            return true;\n        }\n        else {\n            for (var key in this.tileCacheForProjection) {\n                if (this.tileCacheForProjection[key].canExpireCache()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n    TileImage.prototype.expireCache = function (projection, usedTiles) {\n        if (!ENABLE_RASTER_REPROJECTION) {\n            _super.prototype.expireCache.call(this, projection, usedTiles);\n            return;\n        }\n        var usedTileCache = this.getTileCacheForProjection(projection);\n        this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\n        for (var id in this.tileCacheForProjection) {\n            var tileCache = this.tileCacheForProjection[id];\n            tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n        }\n    };\n    /**\n     * @return {Object|undefined} Context options.\n     */\n    TileImage.prototype.getContextOptions = function () {\n        return this.contextOptions_;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {number} Gutter.\n     */\n    TileImage.prototype.getGutterForProjection = function (projection) {\n        if (ENABLE_RASTER_REPROJECTION &&\n            this.getProjection() &&\n            projection &&\n            !equivalent(this.getProjection(), projection)) {\n            return 0;\n        }\n        else {\n            return this.getGutter();\n        }\n    };\n    /**\n     * @return {number} Gutter.\n     */\n    TileImage.prototype.getGutter = function () {\n        return 0;\n    };\n    /**\n     * Return the key to be used for all tiles in the source.\n     * @return {string} The key for all tiles.\n     * @protected\n     */\n    TileImage.prototype.getKey = function () {\n        return (_super.prototype.getKey.call(this) +\n            (this.contextOptions_ ? '\\n' + JSON.stringify(this.contextOptions_) : ''));\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {boolean} Opaque.\n     */\n    TileImage.prototype.getOpaque = function (projection) {\n        if (ENABLE_RASTER_REPROJECTION &&\n            this.getProjection() &&\n            projection &&\n            !equivalent(this.getProjection(), projection)) {\n            return false;\n        }\n        else {\n            return _super.prototype.getOpaque.call(this, projection);\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     */\n    TileImage.prototype.getTileGridForProjection = function (projection) {\n        if (!ENABLE_RASTER_REPROJECTION) {\n            return _super.prototype.getTileGridForProjection.call(this, projection);\n        }\n        var thisProj = this.getProjection();\n        if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n            return this.tileGrid;\n        }\n        else {\n            var projKey = getUid(projection);\n            if (!(projKey in this.tileGridForProjection)) {\n                this.tileGridForProjection[projKey] = getTileGridForProjection(projection);\n            }\n            return this.tileGridForProjection[projKey];\n        }\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../TileCache.js\").default} Tile cache.\n     */\n    TileImage.prototype.getTileCacheForProjection = function (projection) {\n        if (!ENABLE_RASTER_REPROJECTION) {\n            return _super.prototype.getTileCacheForProjection.call(this, projection);\n        }\n        var thisProj = this.getProjection();\n        if (!thisProj || equivalent(thisProj, projection)) {\n            return this.tileCache;\n        }\n        else {\n            var projKey = getUid(projection);\n            if (!(projKey in this.tileCacheForProjection)) {\n                this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);\n            }\n            return this.tileCacheForProjection[projKey];\n        }\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {string} key The key set on the tile.\n     * @return {!import(\"../Tile.js\").default} Tile.\n     * @private\n     */\n    TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {\n        var tileCoord = [z, x, y];\n        var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var tileUrl = urlTileCoord\n            ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)\n            : undefined;\n        var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);\n        tile.key = key;\n        tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n        return tile;\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../Tile.js\").default} Tile.\n     */\n    TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        var sourceProjection = this.getProjection();\n        if (!ENABLE_RASTER_REPROJECTION ||\n            !sourceProjection ||\n            !projection ||\n            equivalent(sourceProjection, projection)) {\n            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);\n        }\n        else {\n            var cache = this.getTileCacheForProjection(projection);\n            var tileCoord = [z, x, y];\n            var tile = void 0;\n            var tileCoordKey = getKey(tileCoord);\n            if (cache.containsKey(tileCoordKey)) {\n                tile = cache.get(tileCoordKey);\n            }\n            var key = this.getKey();\n            if (tile && tile.key == key) {\n                return tile;\n            }\n            else {\n                var sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n                var targetTileGrid = this.getTileGridForProjection(projection);\n                var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n                var newTile = new ReprojTile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {\n                    return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\n                }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.contextOptions_);\n                newTile.key = key;\n                if (tile) {\n                    newTile.interimTile = tile;\n                    newTile.refreshInterimChain();\n                    cache.replace(tileCoordKey, newTile);\n                }\n                else {\n                    cache.set(tileCoordKey, newTile);\n                }\n                return newTile;\n            }\n        }\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {!import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../Tile.js\").default} Tile.\n     * @protected\n     */\n    TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {\n        var tile = null;\n        var tileCoordKey = getKeyZXY(z, x, y);\n        var key = this.getKey();\n        if (!this.tileCache.containsKey(tileCoordKey)) {\n            tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n            this.tileCache.set(tileCoordKey, tile);\n        }\n        else {\n            tile = this.tileCache.get(tileCoordKey);\n            if (tile.key != key) {\n                // The source's params changed. If the tile has an interim tile and if we\n                // can use it then we use it. Otherwise we create a new tile.  In both\n                // cases we attempt to assign an interim tile to the new tile.\n                var interimTile = tile;\n                tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n                //make the new tile the head of the list,\n                if (interimTile.getState() == TileState.IDLE) {\n                    //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it\n                    tile.interimTile = interimTile.interimTile;\n                }\n                else {\n                    tile.interimTile = interimTile;\n                }\n                tile.refreshInterimChain();\n                this.tileCache.replace(tileCoordKey, tile);\n            }\n        }\n        return tile;\n    };\n    /**\n     * Sets whether to render reprojection edges or not (usually for debugging).\n     * @param {boolean} render Render the edges.\n     * @api\n     */\n    TileImage.prototype.setRenderReprojectionEdges = function (render) {\n        if (!ENABLE_RASTER_REPROJECTION ||\n            this.renderReprojectionEdges_ == render) {\n            return;\n        }\n        this.renderReprojectionEdges_ = render;\n        for (var id in this.tileCacheForProjection) {\n            this.tileCacheForProjection[id].clear();\n        }\n        this.changed();\n    };\n    /**\n     * Sets the tile grid to use when reprojecting the tiles to the given\n     * projection instead of the default tile grid for the projection.\n     *\n     * This can be useful when the default tile grid cannot be created\n     * (e.g. projection has no extent defined) or\n     * for optimization reasons (custom tile size, resolutions, ...).\n     *\n     * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n     * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n     * @api\n     */\n    TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {\n        if (ENABLE_RASTER_REPROJECTION) {\n            var proj = getProjection(projection);\n            if (proj) {\n                var projKey = getUid(proj);\n                if (!(projKey in this.tileGridForProjection)) {\n                    this.tileGridForProjection[projKey] = tilegrid;\n                }\n            }\n        }\n    };\n    return TileImage;\n}(UrlTile));\n/**\n * @param {ImageTile} imageTile Image tile.\n * @param {string} src Source.\n */\nfunction defaultTileLoadFunction(imageTile, src) {\n    /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src = src;\n}\nexport default TileImage;\n//# sourceMappingURL=TileImage.js.map","/**\n * @module ol/source/TileJSON\n */\n// FIXME check order of async callbacks\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * See https://mapbox.com/developers/api/.\n */\nimport SourceState from './State.js';\nimport TileImage from './TileImage.js';\nimport { applyTransform, intersects } from '../extent.js';\nimport { assert } from '../asserts.js';\nimport { createFromTemplates } from '../tileurlfunction.js';\nimport { createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { get as getProjection, getTransformFromProjections } from '../proj.js';\nimport { jsonp as requestJSONP } from '../net.js';\n/**\n * @typedef {Object} Config\n * @property {string} [name] The name.\n * @property {string} [description] The description.\n * @property {string} [version] The version.\n * @property {string} [attribution] The attribution.\n * @property {string} [template] The template.\n * @property {string} [legend] The legend.\n * @property {string} [scheme] The scheme.\n * @property {Array<string>} tiles The tile URL templates.\n * @property {Array<string>} [grids] Optional grids.\n * @property {number} [minzoom] Minimum zoom level.\n * @property {number} [maxzoom] Maximum zoom level.\n * @property {Array<number>} [bounds] Optional bounds.\n * @property {Array<number>} [center] Optional center.\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {Config} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.\n * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n */\n/**\n * @classdesc\n * Layer source for tile data in TileJSON format.\n * @api\n */\nvar TileJSON = /** @class */ (function (_super) {\n    __extends(TileJSON, _super);\n    /**\n     * @param {Options} options TileJSON options.\n     */\n    function TileJSON(options) {\n        var _this = _super.call(this, {\n            attributions: options.attributions,\n            cacheSize: options.cacheSize,\n            crossOrigin: options.crossOrigin,\n            imageSmoothing: options.imageSmoothing,\n            projection: getProjection('EPSG:3857'),\n            reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n            state: SourceState.LOADING,\n            tileLoadFunction: options.tileLoadFunction,\n            wrapX: options.wrapX !== undefined ? options.wrapX : true,\n            transition: options.transition,\n        }) || this;\n        /**\n         * @type {Config}\n         * @private\n         */\n        _this.tileJSON_ = null;\n        /**\n         * @type {number|import(\"../size.js\").Size}\n         * @private\n         */\n        _this.tileSize_ = options.tileSize;\n        if (options.url) {\n            if (options.jsonp) {\n                requestJSONP(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));\n            }\n            else {\n                var client = new XMLHttpRequest();\n                client.addEventListener('load', _this.onXHRLoad_.bind(_this));\n                client.addEventListener('error', _this.onXHRError_.bind(_this));\n                client.open('GET', options.url);\n                client.send();\n            }\n        }\n        else if (options.tileJSON) {\n            _this.handleTileJSONResponse(options.tileJSON);\n        }\n        else {\n            assert(false, 51); // Either `url` or `tileJSON` options must be provided\n        }\n        return _this;\n    }\n    /**\n     * @private\n     * @param {Event} event The load event.\n     */\n    TileJSON.prototype.onXHRLoad_ = function (event) {\n        var client = /** @type {XMLHttpRequest} */ (event.target);\n        // status will be 0 for file:// urls\n        if (!client.status || (client.status >= 200 && client.status < 300)) {\n            var response = void 0;\n            try {\n                response = /** @type {TileJSON} */ (JSON.parse(client.responseText));\n            }\n            catch (err) {\n                this.handleTileJSONError();\n                return;\n            }\n            this.handleTileJSONResponse(response);\n        }\n        else {\n            this.handleTileJSONError();\n        }\n    };\n    /**\n     * @private\n     * @param {Event} event The error event.\n     */\n    TileJSON.prototype.onXHRError_ = function (event) {\n        this.handleTileJSONError();\n    };\n    /**\n     * @return {Config} The tilejson object.\n     * @api\n     */\n    TileJSON.prototype.getTileJSON = function () {\n        return this.tileJSON_;\n    };\n    /**\n     * @protected\n     * @param {Config} tileJSON Tile JSON.\n     */\n    TileJSON.prototype.handleTileJSONResponse = function (tileJSON) {\n        var epsg4326Projection = getProjection('EPSG:4326');\n        var sourceProjection = this.getProjection();\n        var extent;\n        if (tileJSON['bounds'] !== undefined) {\n            var transform = getTransformFromProjections(epsg4326Projection, sourceProjection);\n            extent = applyTransform(tileJSON['bounds'], transform);\n        }\n        var minZoom = tileJSON['minzoom'] || 0;\n        var maxZoom = tileJSON['maxzoom'] || 22;\n        var tileGrid = createXYZ({\n            extent: extentFromProjection(sourceProjection),\n            maxZoom: maxZoom,\n            minZoom: minZoom,\n            tileSize: this.tileSize_,\n        });\n        this.tileGrid = tileGrid;\n        this.tileUrlFunction = createFromTemplates(tileJSON['tiles'], tileGrid);\n        if (tileJSON['attribution'] !== undefined && !this.getAttributions()) {\n            var attributionExtent_1 = extent !== undefined ? extent : epsg4326Projection.getExtent();\n            this.setAttributions(function (frameState) {\n                if (intersects(attributionExtent_1, frameState.extent)) {\n                    return [tileJSON['attribution']];\n                }\n                return null;\n            });\n        }\n        this.tileJSON_ = tileJSON;\n        this.setState(SourceState.READY);\n    };\n    /**\n     * @protected\n     */\n    TileJSON.prototype.handleTileJSONError = function () {\n        this.setState(SourceState.ERROR);\n    };\n    return TileJSON;\n}(TileImage));\nexport default TileJSON;\n//# sourceMappingURL=TileJSON.js.map","/**\n * @module ol/source/State\n */\n/**\n * @enum {string}\n * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\n */\nexport default {\n    UNDEFINED: 'undefined',\n    LOADING: 'loading',\n    READY: 'ready',\n    ERROR: 'error',\n};\n//# sourceMappingURL=State.js.map","/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, { createOrUpdate as createOrUpdateTileRange, } from '../TileRange.js';\nimport { DEFAULT_TILE_SIZE } from './common.js';\nimport { assert } from '../asserts.js';\nimport { clamp } from '../math.js';\nimport { createOrUpdate, getTopLeft } from '../extent.js';\nimport { createOrUpdate as createOrUpdateTileCoord } from '../tilecoord.js';\nimport { isSorted, linearFindNearest } from '../array.js';\nimport { toSize } from '../size.js';\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nvar tmpTileCoord = [0, 0, 0];\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nvar TileGrid = /** @class */ (function () {\n    /**\n     * @param {Options} options Tile grid options.\n     */\n    function TileGrid(options) {\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n        /**\n         * @private\n         * @type {!Array<number>}\n         */\n        this.resolutions_ = options.resolutions;\n        assert(isSorted(this.resolutions_, function (a, b) {\n            return b - a;\n        }, true), 17); // `resolutions` must be sorted in descending order\n        // check if we've got a consistent zoom factor and origin\n        var zoomFactor;\n        if (!options.origins) {\n            for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n                if (!zoomFactor) {\n                    zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n                }\n                else {\n                    if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n                        zoomFactor = undefined;\n                        break;\n                    }\n                }\n            }\n        }\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        this.zoomFactor_ = zoomFactor;\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.maxZoom = this.resolutions_.length - 1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        this.origin_ = options.origin !== undefined ? options.origin : null;\n        /**\n         * @private\n         * @type {Array<import(\"../coordinate.js\").Coordinate>}\n         */\n        this.origins_ = null;\n        if (options.origins !== undefined) {\n            this.origins_ = options.origins;\n            assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n        }\n        var extent = options.extent;\n        if (extent !== undefined && !this.origin_ && !this.origins_) {\n            this.origin_ = getTopLeft(extent);\n        }\n        assert((!this.origin_ && this.origins_) || (this.origin_ && !this.origins_), 18); // Either `origin` or `origins` must be configured, never both\n        /**\n         * @private\n         * @type {Array<number|import(\"../size.js\").Size>}\n         */\n        this.tileSizes_ = null;\n        if (options.tileSizes !== undefined) {\n            this.tileSizes_ = options.tileSizes;\n            assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n        }\n        /**\n         * @private\n         * @type {number|import(\"../size.js\").Size}\n         */\n        this.tileSize_ =\n            options.tileSize !== undefined\n                ? options.tileSize\n                : !this.tileSizes_\n                    ? DEFAULT_TILE_SIZE\n                    : null;\n        assert((!this.tileSize_ && this.tileSizes_) ||\n            (this.tileSize_ && !this.tileSizes_), 22); // Either `tileSize` or `tileSizes` must be configured, never both\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        this.extent_ = extent !== undefined ? extent : null;\n        /**\n         * @private\n         * @type {Array<import(\"../TileRange.js\").default>}\n         */\n        this.fullTileRanges_ = null;\n        /**\n         * @private\n         * @type {import(\"../size.js\").Size}\n         */\n        this.tmpSize_ = [0, 0];\n        if (options.sizes !== undefined) {\n            this.fullTileRanges_ = options.sizes.map(function (size, z) {\n                var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n                if (extent) {\n                    var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n                    tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n                    tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n                    tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n                    tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n                }\n                return tileRange;\n            }, this);\n        }\n        else if (extent) {\n            this.calculateTileRanges_(extent);\n        }\n    }\n    /**\n     * Call a function with each tile coordinate for a given extent and zoom level.\n     *\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} zoom Integer zoom level.\n     * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {\n        var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n        for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n            for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n                callback([zoom, i, j]);\n            }\n        }\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n     * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n     * @return {boolean} Callback succeeded.\n     */\n    TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {\n        var tileRange, x, y;\n        var tileCoordExtent = null;\n        var z = tileCoord[0] - 1;\n        if (this.zoomFactor_ === 2) {\n            x = tileCoord[1];\n            y = tileCoord[2];\n        }\n        else {\n            tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n        }\n        while (z >= this.minZoom) {\n            if (this.zoomFactor_ === 2) {\n                x = Math.floor(x / 2);\n                y = Math.floor(y / 2);\n                tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n            }\n            else {\n                tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n            }\n            if (callback(z, tileRange)) {\n                return true;\n            }\n            --z;\n        }\n        return false;\n    };\n    /**\n     * Get the extent for this tile grid, if it was configured.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getExtent = function () {\n        return this.extent_;\n    };\n    /**\n     * Get the maximum zoom level for the grid.\n     * @return {number} Max zoom.\n     * @api\n     */\n    TileGrid.prototype.getMaxZoom = function () {\n        return this.maxZoom;\n    };\n    /**\n     * Get the minimum zoom level for the grid.\n     * @return {number} Min zoom.\n     * @api\n     */\n    TileGrid.prototype.getMinZoom = function () {\n        return this.minZoom;\n    };\n    /**\n     * Get the origin for the grid at the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {import(\"../coordinate.js\").Coordinate} Origin.\n     * @api\n     */\n    TileGrid.prototype.getOrigin = function (z) {\n        if (this.origin_) {\n            return this.origin_;\n        }\n        else {\n            return this.origins_[z];\n        }\n    };\n    /**\n     * Get the resolution for the given zoom level.\n     * @param {number} z Integer zoom level.\n     * @return {number} Resolution.\n     * @api\n     */\n    TileGrid.prototype.getResolution = function (z) {\n        return this.resolutions_[z];\n    };\n    /**\n     * Get the list of resolutions for the tile grid.\n     * @return {Array<number>} Resolutions.\n     * @api\n     */\n    TileGrid.prototype.getResolutions = function () {\n        return this.resolutions_;\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n     * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {\n        if (tileCoord[0] < this.maxZoom) {\n            if (this.zoomFactor_ === 2) {\n                var minX = tileCoord[1] * 2;\n                var minY = tileCoord[2] * 2;\n                return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, opt_tileRange);\n            }\n            var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n            return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n        }\n        return null;\n    };\n    /**\n     * Get the extent for a tile range.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n     * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     */\n    TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n        var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n        var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n        var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get a tile range for the given extent and integer zoom level.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} z Integer zoom level.\n     * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary tile range object.\n     * @return {import(\"../TileRange.js\").default} Tile range.\n     */\n    TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {\n        var tileCoord = tmpTileCoord;\n        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);\n        var minX = tileCoord[1];\n        var minY = tileCoord[2];\n        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);\n        return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n     */\n    TileGrid.prototype.getTileCoordCenter = function (tileCoord) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        return [\n            origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n            origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n        ];\n    };\n    /**\n     * Get the extent of a tile coordinate.\n     *\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @param {import(\"../extent.js\").Extent=} opt_extent Temporary extent object.\n     * @return {import(\"../extent.js\").Extent} Extent.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {\n        var origin = this.getOrigin(tileCoord[0]);\n        var resolution = this.getResolution(tileCoord[0]);\n        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n        var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n        var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n        var maxX = minX + tileSize[0] * resolution;\n        var maxY = minY + tileSize[1] * resolution;\n        return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n    };\n    /**\n     * Get the tile coordinate for the given map coordinate and resolution.  This\n     * method considers that coordinates that intersect tile boundaries should be\n     * assigned the higher tile coordinate.\n     *\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {\n        return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n    };\n    /**\n     * Note that this method should not be called for resolutions that correspond\n     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {number} resolution Resolution (for a non-integer zoom level).\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n        var z = this.getZForResolution(resolution);\n        var scale = resolution / this.getResolution(z);\n        var origin = this.getOrigin(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n        var adjustY = reverseIntersectionPolicy ? 0.5 : 0;\n        var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n        var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);\n        var tileCoordX = (scale * xFromOrigin) / tileSize[0];\n        var tileCoordY = (scale * yFromOrigin) / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = Math.ceil(tileCoordX) - 1;\n            tileCoordY = Math.ceil(tileCoordY) - 1;\n        }\n        else {\n            tileCoordX = Math.floor(tileCoordX);\n            tileCoordY = Math.floor(tileCoordY);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n     * they should have separate implementations.  This method is for integer zoom\n     * levels.  The other method should only be called for resolutions corresponding\n     * to non-integer zoom levels.\n     * @param {number} x Map x coordinate.\n     * @param {number} y Map y coordinate.\n     * @param {number} z Integer zoom level.\n     * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n     *     intersections go to the higher tile coordinate, let edge intersections\n     *     go to the lower tile coordinate.\n     * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @private\n     */\n    TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n        var origin = this.getOrigin(z);\n        var resolution = this.getResolution(z);\n        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n        var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n        var adjustY = reverseIntersectionPolicy ? 0.5 : 0;\n        var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n        var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);\n        var tileCoordX = xFromOrigin / tileSize[0];\n        var tileCoordY = yFromOrigin / tileSize[1];\n        if (reverseIntersectionPolicy) {\n            tileCoordX = Math.ceil(tileCoordX) - 1;\n            tileCoordY = Math.ceil(tileCoordY) - 1;\n        }\n        else {\n            tileCoordX = Math.floor(tileCoordX);\n            tileCoordY = Math.floor(tileCoordY);\n        }\n        return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n    };\n    /**\n     * Get a tile coordinate given a map coordinate and zoom level.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {number} z Zoom level.\n     * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n     * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n     * @api\n     */\n    TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {\n        return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);\n    };\n    /**\n     * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n     * @return {number} Tile resolution.\n     */\n    TileGrid.prototype.getTileCoordResolution = function (tileCoord) {\n        return this.resolutions_[tileCoord[0]];\n    };\n    /**\n     * Get the tile size for a zoom level. The type of the return value matches the\n     * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n     * get an `import(\"../size.js\").Size`, run the result through `import(\"../size.js\").Size.toSize()`.\n     * @param {number} z Z.\n     * @return {number|import(\"../size.js\").Size} Tile size.\n     * @api\n     */\n    TileGrid.prototype.getTileSize = function (z) {\n        if (this.tileSize_) {\n            return this.tileSize_;\n        }\n        else {\n            return this.tileSizes_[z];\n        }\n    };\n    /**\n     * @param {number} z Zoom level.\n     * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n     */\n    TileGrid.prototype.getFullTileRange = function (z) {\n        if (!this.fullTileRanges_) {\n            return this.extent_\n                ? this.getTileRangeForExtentAndZ(this.extent_, z)\n                : null;\n        }\n        else {\n            return this.fullTileRanges_[z];\n        }\n    };\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number=} opt_direction If 0, the nearest resolution will be used.\n     *     If 1, the nearest lower resolution will be used. If -1, the nearest\n     *     higher resolution will be used. Default is 0.\n     * @return {number} Z.\n     * @api\n     */\n    TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {\n        var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n        return clamp(z, this.minZoom, this.maxZoom);\n    };\n    /**\n     * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n     * @private\n     */\n    TileGrid.prototype.calculateTileRanges_ = function (extent) {\n        var length = this.resolutions_.length;\n        var fullTileRanges = new Array(length);\n        for (var z = this.minZoom; z < length; ++z) {\n            fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n        }\n        this.fullTileRanges_ = fullTileRanges;\n    };\n    return TileGrid;\n}());\nexport default TileGrid;\n//# sourceMappingURL=TileGrid.js.map","/**\n * @module ol/sphere\n */\nimport GeometryType from './geom/GeometryType.js';\nimport { toDegrees, toRadians } from './math.js';\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\n * for the WGS84 ellipsoid is used.\n */\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport var DEFAULT_RADIUS = 6371008.8;\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, opt_radius) {\n    var radius = opt_radius || DEFAULT_RADIUS;\n    var lat1 = toRadians(c1[1]);\n    var lat2 = toRadians(c2[1]);\n    var deltaLatBy2 = (lat2 - lat1) / 2;\n    var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n    var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n        Math.sin(deltaLonBy2) *\n            Math.sin(deltaLonBy2) *\n            Math.cos(lat1) *\n            Math.cos(lat2);\n    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n    var length = 0;\n    for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n        length += getDistance(coordinates[i], coordinates[i + 1], radius);\n    }\n    return length;\n}\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions=} opt_options Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, opt_options) {\n    var options = opt_options || {};\n    var radius = options.radius || DEFAULT_RADIUS;\n    var projection = options.projection || 'EPSG:3857';\n    var type = geometry.getType();\n    if (type !== GeometryType.GEOMETRY_COLLECTION) {\n        geometry = geometry.clone().transform(projection, 'EPSG:4326');\n    }\n    var length = 0;\n    var coordinates, coords, i, ii, j, jj;\n    switch (type) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT: {\n            break;\n        }\n        case GeometryType.LINE_STRING:\n        case GeometryType.LINEAR_RING: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            length = getLengthInternal(coordinates, radius);\n            break;\n        }\n        case GeometryType.MULTI_LINE_STRING:\n        case GeometryType.POLYGON: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            for (i = 0, ii = coordinates.length; i < ii; ++i) {\n                length += getLengthInternal(coordinates[i], radius);\n            }\n            break;\n        }\n        case GeometryType.MULTI_POLYGON: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            for (i = 0, ii = coordinates.length; i < ii; ++i) {\n                coords = coordinates[i];\n                for (j = 0, jj = coords.length; j < jj; ++j) {\n                    length += getLengthInternal(coords[j], radius);\n                }\n            }\n            break;\n        }\n        case GeometryType.GEOMETRY_COLLECTION: {\n            var geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n            for (i = 0, ii = geometries.length; i < ii; ++i) {\n                length += getLength(geometries[i], opt_options);\n            }\n            break;\n        }\n        default: {\n            throw new Error('Unsupported geometry type: ' + type);\n        }\n    }\n    return length;\n}\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n    var area = 0;\n    var len = coordinates.length;\n    var x1 = coordinates[len - 1][0];\n    var y1 = coordinates[len - 1][1];\n    for (var i = 0; i < len; i++) {\n        var x2 = coordinates[i][0];\n        var y2 = coordinates[i][1];\n        area +=\n            toRadians(x2 - x1) *\n                (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\n        x1 = x2;\n        y1 = y2;\n    }\n    return (area * radius * radius) / 2.0;\n}\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions=} opt_options Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, opt_options) {\n    var options = opt_options || {};\n    var radius = options.radius || DEFAULT_RADIUS;\n    var projection = options.projection || 'EPSG:3857';\n    var type = geometry.getType();\n    if (type !== GeometryType.GEOMETRY_COLLECTION) {\n        geometry = geometry.clone().transform(projection, 'EPSG:4326');\n    }\n    var area = 0;\n    var coordinates, coords, i, ii, j, jj;\n    switch (type) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT:\n        case GeometryType.LINE_STRING:\n        case GeometryType.MULTI_LINE_STRING:\n        case GeometryType.LINEAR_RING: {\n            break;\n        }\n        case GeometryType.POLYGON: {\n            coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (geometry).getCoordinates();\n            area = Math.abs(getAreaInternal(coordinates[0], radius));\n            for (i = 1, ii = coordinates.length; i < ii; ++i) {\n                area -= Math.abs(getAreaInternal(coordinates[i], radius));\n            }\n            break;\n        }\n        case GeometryType.MULTI_POLYGON: {\n            coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (geometry).getCoordinates();\n            for (i = 0, ii = coordinates.length; i < ii; ++i) {\n                coords = coordinates[i];\n                area += Math.abs(getAreaInternal(coords[0], radius));\n                for (j = 1, jj = coords.length; j < jj; ++j) {\n                    area -= Math.abs(getAreaInternal(coords[j], radius));\n                }\n            }\n            break;\n        }\n        case GeometryType.GEOMETRY_COLLECTION: {\n            var geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */ (geometry).getGeometries();\n            for (i = 0, ii = geometries.length; i < ii; ++i) {\n                area += getArea(geometries[i], opt_options);\n            }\n            break;\n        }\n        default: {\n            throw new Error('Unsupported geometry type: ' + type);\n        }\n    }\n    return area;\n}\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, opt_radius) {\n    var radius = opt_radius || DEFAULT_RADIUS;\n    var lat1 = toRadians(c1[1]);\n    var lon1 = toRadians(c1[0]);\n    var dByR = distance / radius;\n    var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) +\n        Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n    var lon = lon1 +\n        Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n    return [toDegrees(lon), toDegrees(lat)];\n}\n//# sourceMappingURL=sphere.js.map","/**\n * @module ol/rotationconstraint\n */\nimport { toRadians } from './math.js';\n/**\n * @typedef {function((number|undefined), boolean=): (number|undefined)} Type\n */\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function disable(rotation) {\n    if (rotation !== undefined) {\n        return 0;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function none(rotation) {\n    if (rotation !== undefined) {\n        return rotation;\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * @param {number} n N.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToN(n) {\n    var theta = (2 * Math.PI) / n;\n    return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, opt_isMoving) {\n        if (opt_isMoving) {\n            return rotation;\n        }\n        if (rotation !== undefined) {\n            rotation = Math.floor(rotation / theta + 0.5) * theta;\n            return rotation;\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number=} opt_tolerance Tolerance.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToZero(opt_tolerance) {\n    var tolerance = opt_tolerance || toRadians(5);\n    return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, opt_isMoving) {\n        if (opt_isMoving) {\n            return rotation;\n        }\n        if (rotation !== undefined) {\n            if (Math.abs(rotation) <= tolerance) {\n                return 0;\n            }\n            else {\n                return rotation;\n            }\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n//# sourceMappingURL=rotationconstraint.js.map","/**\n * @module ol/transform\n */\nimport { assert } from './asserts.js';\n/**\n * An array representing an affine 2d transformation for use with\n * {@link module:ol/transform} functions. The array has 6 elements.\n * @typedef {!Array<number>} Transform\n * @api\n */\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 33 matrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n/**\n * @private\n * @type {Transform}\n */\nvar tmp_ = new Array(6);\n/**\n * Create an identity transform.\n * @return {!Transform} Identity transform.\n */\nexport function create() {\n    return [1, 0, 0, 1, 0, 0];\n}\n/**\n * Resets the given transform to an identity transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Transform.\n */\nexport function reset(transform) {\n    return set(transform, 1, 0, 0, 1, 0, 0);\n}\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!Transform} transform1 Transform parameters of matrix 1.\n * @param {!Transform} transform2 Transform parameters of matrix 2.\n * @return {!Transform} transform1 multiplied with transform2.\n */\nexport function multiply(transform1, transform2) {\n    var a1 = transform1[0];\n    var b1 = transform1[1];\n    var c1 = transform1[2];\n    var d1 = transform1[3];\n    var e1 = transform1[4];\n    var f1 = transform1[5];\n    var a2 = transform2[0];\n    var b2 = transform2[1];\n    var c2 = transform2[2];\n    var d2 = transform2[3];\n    var e2 = transform2[4];\n    var f2 = transform2[5];\n    transform1[0] = a1 * a2 + c1 * b2;\n    transform1[1] = b1 * a2 + d1 * b2;\n    transform1[2] = a1 * c2 + c1 * d2;\n    transform1[3] = b1 * c2 + d1 * d2;\n    transform1[4] = a1 * e2 + c1 * f2 + e1;\n    transform1[5] = b1 * e2 + d1 * f2 + f1;\n    return transform1;\n}\n/**\n * Set the transform components a-f on a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!Transform} Matrix with transform applied.\n */\nexport function set(transform, a, b, c, d, e, f) {\n    transform[0] = a;\n    transform[1] = b;\n    transform[2] = c;\n    transform[3] = d;\n    transform[4] = e;\n    transform[5] = f;\n    return transform;\n}\n/**\n * Set transform on one matrix from another matrix.\n * @param {!Transform} transform1 Matrix to set transform to.\n * @param {!Transform} transform2 Matrix to set transform from.\n * @return {!Transform} transform1 with transform from transform2 applied.\n */\nexport function setFromArray(transform1, transform2) {\n    transform1[0] = transform2[0];\n    transform1[1] = transform2[1];\n    transform1[2] = transform2[2];\n    transform1[3] = transform2[3];\n    transform1[4] = transform2[4];\n    transform1[5] = transform2[5];\n    return transform1;\n}\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {Transform} transform The transformation.\n * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\n * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\n *     chained together.\n */\nexport function apply(transform, coordinate) {\n    var x = coordinate[0];\n    var y = coordinate[1];\n    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n    return coordinate;\n}\n/**\n * Applies rotation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!Transform} The rotated transform.\n */\nexport function rotate(transform, angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n}\n/**\n * Applies scale to a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scaled transform.\n */\nexport function scale(transform, x, y) {\n    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n}\n/**\n * Creates a scale transform.\n * @param {!Transform} target Transform to overwrite.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scale transform.\n */\nexport function makeScale(target, x, y) {\n    return set(target, x, 0, 0, y, 0, 0);\n}\n/**\n * Applies translation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!Transform} The translated transform.\n */\nexport function translate(transform, dx, dy) {\n    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n}\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!Transform} The composite transform.\n */\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n    var sin = Math.sin(angle);\n    var cos = Math.cos(angle);\n    transform[0] = sx * cos;\n    transform[1] = sy * sin;\n    transform[2] = -sx * sin;\n    transform[3] = sy * cos;\n    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n    return transform;\n}\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative). The resulting transform\n * string can be applied as `transform` porperty of an HTMLElement's style.\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {string} The composite css transform.\n * @api\n */\nexport function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {\n    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));\n}\n/**\n * Invert the given transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (source) transform.\n */\nexport function invert(source) {\n    return makeInverse(source, source);\n}\n/**\n * Invert the given transform.\n * @param {!Transform} target Transform to be set as the inverse of\n *     the source transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (target) transform.\n */\nexport function makeInverse(target, source) {\n    var det = determinant(source);\n    assert(det !== 0, 32); // Transformation matrix cannot be inverted\n    var a = source[0];\n    var b = source[1];\n    var c = source[2];\n    var d = source[3];\n    var e = source[4];\n    var f = source[5];\n    target[0] = d / det;\n    target[1] = -b / det;\n    target[2] = -c / det;\n    target[3] = a / det;\n    target[4] = (c * f - d * e) / det;\n    target[5] = -(a * f - b * e) / det;\n    return target;\n}\n/**\n * Returns the determinant of the given matrix.\n * @param {!Transform} mat Matrix.\n * @return {number} Determinant.\n */\nexport function determinant(mat) {\n    return mat[0] * mat[3] - mat[1] * mat[2];\n}\n/**\n * A string version of the transform.  This can be used\n * for CSS transforms.\n * @param {!Transform} mat Matrix.\n * @return {string} The transform as a string.\n */\nexport function toString(mat) {\n    return 'matrix(' + mat.join(', ') + ')';\n}\n//# sourceMappingURL=transform.js.map","/**\n * @module ol/resolutionconstraint\n */\nimport { clamp } from './math.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { linearFindNearest } from './array.js';\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n    var xResolution = getWidth(maxExtent) / viewportSize[0];\n    var yResolution = getHeight(maxExtent) / viewportSize[1];\n    if (showFullExtent) {\n        return Math.min(resolution, Math.max(xResolution, yResolution));\n    }\n    return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n    var result = Math.min(resolution, maxResolution);\n    var ratio = 50;\n    result *=\n        Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\n            1;\n    if (minResolution) {\n        result = Math.max(result, minResolution);\n        result /=\n            Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\n                ratio +\n                1;\n    }\n    return clamp(result, minResolution / 2, maxResolution * 2);\n}\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent=} opt_maxExtent Maximum allowed extent.\n * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var maxResolution = resolutions[0];\n            var minResolution = resolutions[resolutions.length - 1];\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var capped = Math.min(cappedMaxRes, resolution);\n            var z = Math.floor(linearFindNearest(resolutions, capped, direction));\n            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n                return resolutions[z + 1];\n            }\n            return resolutions[z];\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number=} opt_minResolution Minimum resolution.\n * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent=} opt_maxExtent Maximum allowed extent.\n * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;\n            // during interacting or animating, allow intermediary values\n            if (opt_isMoving) {\n                var smooth = opt_smooth !== undefined ? opt_smooth : true;\n                if (!smooth) {\n                    return clamp(resolution, minResolution, cappedMaxRes);\n                }\n                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n            }\n            var tolerance = 1e-9;\n            var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n            var offset = -direction * (0.5 - tolerance) + 0.5;\n            var capped = Math.min(cappedMaxRes, resolution);\n            var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n            var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n            var newResolution = maxResolution / Math.pow(power, zoomLevel);\n            return clamp(newResolution, minResolution, cappedMaxRes);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent=} opt_maxExtent Maximum allowed extent.\n * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {\n    return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, opt_isMoving) {\n        if (resolution !== undefined) {\n            var cappedMaxRes = opt_maxExtent\n                ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)\n                : maxResolution;\n            var smooth = opt_smooth !== undefined ? opt_smooth : true;\n            if (!smooth || !opt_isMoving) {\n                return clamp(resolution, minResolution, cappedMaxRes);\n            }\n            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n//# sourceMappingURL=resolutionconstraint.js.map","/**\n * @module ol/string\n */\n/**\n * @param {number} number Number to be formatted\n * @param {number} width The desired width\n * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)\n * @returns {string} Formatted string\n */\nexport function padNumber(number, width, opt_precision) {\n    var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;\n    var decimal = numberString.indexOf('.');\n    decimal = decimal === -1 ? numberString.length : decimal;\n    return decimal > width\n        ? numberString\n        : new Array(1 + width - decimal).join('0') + numberString;\n}\n/**\n * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\n * @param {string|number} v1 First version\n * @param {string|number} v2 Second version\n * @returns {number} Value\n */\nexport function compareVersions(v1, v2) {\n    var s1 = ('' + v1).split('.');\n    var s2 = ('' + v2).split('.');\n    for (var i = 0; i < Math.max(s1.length, s2.length); i++) {\n        var n1 = parseInt(s1[i] || '0', 10);\n        var n2 = parseInt(s2[i] || '0', 10);\n        if (n1 > n2) {\n            return 1;\n        }\n        if (n2 > n1) {\n            return -1;\n        }\n    }\n    return 0;\n}\n//# sourceMappingURL=string.js.map","/**\n * @module ol/structs/PriorityQueue\n */\nimport { assert } from '../asserts.js';\nimport { clear } from '../obj.js';\n/**\n * @type {number}\n */\nexport var DROP = Infinity;\n/**\n * @classdesc\n * Priority queue.\n *\n * The implementation is inspired from the Closure Library's Heap class and\n * Python's heapq module.\n *\n * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html\n * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.\n *\n * @template T\n */\nvar PriorityQueue = /** @class */ (function () {\n    /**\n     * @param {function(T): number} priorityFunction Priority function.\n     * @param {function(T): string} keyFunction Key function.\n     */\n    function PriorityQueue(priorityFunction, keyFunction) {\n        /**\n         * @type {function(T): number}\n         * @private\n         */\n        this.priorityFunction_ = priorityFunction;\n        /**\n         * @type {function(T): string}\n         * @private\n         */\n        this.keyFunction_ = keyFunction;\n        /**\n         * @type {Array<T>}\n         * @private\n         */\n        this.elements_ = [];\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this.priorities_ = [];\n        /**\n         * @type {!Object<string, boolean>}\n         * @private\n         */\n        this.queuedElements_ = {};\n    }\n    /**\n     * FIXME empty description for jsdoc\n     */\n    PriorityQueue.prototype.clear = function () {\n        this.elements_.length = 0;\n        this.priorities_.length = 0;\n        clear(this.queuedElements_);\n    };\n    /**\n     * Remove and return the highest-priority element. O(log N).\n     * @return {T} Element.\n     */\n    PriorityQueue.prototype.dequeue = function () {\n        var elements = this.elements_;\n        var priorities = this.priorities_;\n        var element = elements[0];\n        if (elements.length == 1) {\n            elements.length = 0;\n            priorities.length = 0;\n        }\n        else {\n            elements[0] = elements.pop();\n            priorities[0] = priorities.pop();\n            this.siftUp_(0);\n        }\n        var elementKey = this.keyFunction_(element);\n        delete this.queuedElements_[elementKey];\n        return element;\n    };\n    /**\n     * Enqueue an element. O(log N).\n     * @param {T} element Element.\n     * @return {boolean} The element was added to the queue.\n     */\n    PriorityQueue.prototype.enqueue = function (element) {\n        assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue\n        var priority = this.priorityFunction_(element);\n        if (priority != DROP) {\n            this.elements_.push(element);\n            this.priorities_.push(priority);\n            this.queuedElements_[this.keyFunction_(element)] = true;\n            this.siftDown_(0, this.elements_.length - 1);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @return {number} Count.\n     */\n    PriorityQueue.prototype.getCount = function () {\n        return this.elements_.length;\n    };\n    /**\n     * Gets the index of the left child of the node at the given index.\n     * @param {number} index The index of the node to get the left child for.\n     * @return {number} The index of the left child.\n     * @private\n     */\n    PriorityQueue.prototype.getLeftChildIndex_ = function (index) {\n        return index * 2 + 1;\n    };\n    /**\n     * Gets the index of the right child of the node at the given index.\n     * @param {number} index The index of the node to get the right child for.\n     * @return {number} The index of the right child.\n     * @private\n     */\n    PriorityQueue.prototype.getRightChildIndex_ = function (index) {\n        return index * 2 + 2;\n    };\n    /**\n     * Gets the index of the parent of the node at the given index.\n     * @param {number} index The index of the node to get the parent for.\n     * @return {number} The index of the parent.\n     * @private\n     */\n    PriorityQueue.prototype.getParentIndex_ = function (index) {\n        return (index - 1) >> 1;\n    };\n    /**\n     * Make this a heap. O(N).\n     * @private\n     */\n    PriorityQueue.prototype.heapify_ = function () {\n        var i;\n        for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {\n            this.siftUp_(i);\n        }\n    };\n    /**\n     * @return {boolean} Is empty.\n     */\n    PriorityQueue.prototype.isEmpty = function () {\n        return this.elements_.length === 0;\n    };\n    /**\n     * @param {string} key Key.\n     * @return {boolean} Is key queued.\n     */\n    PriorityQueue.prototype.isKeyQueued = function (key) {\n        return key in this.queuedElements_;\n    };\n    /**\n     * @param {T} element Element.\n     * @return {boolean} Is queued.\n     */\n    PriorityQueue.prototype.isQueued = function (element) {\n        return this.isKeyQueued(this.keyFunction_(element));\n    };\n    /**\n     * @param {number} index The index of the node to move down.\n     * @private\n     */\n    PriorityQueue.prototype.siftUp_ = function (index) {\n        var elements = this.elements_;\n        var priorities = this.priorities_;\n        var count = elements.length;\n        var element = elements[index];\n        var priority = priorities[index];\n        var startIndex = index;\n        while (index < count >> 1) {\n            var lIndex = this.getLeftChildIndex_(index);\n            var rIndex = this.getRightChildIndex_(index);\n            var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex]\n                ? rIndex\n                : lIndex;\n            elements[index] = elements[smallerChildIndex];\n            priorities[index] = priorities[smallerChildIndex];\n            index = smallerChildIndex;\n        }\n        elements[index] = element;\n        priorities[index] = priority;\n        this.siftDown_(startIndex, index);\n    };\n    /**\n     * @param {number} startIndex The index of the root.\n     * @param {number} index The index of the node to move up.\n     * @private\n     */\n    PriorityQueue.prototype.siftDown_ = function (startIndex, index) {\n        var elements = this.elements_;\n        var priorities = this.priorities_;\n        var element = elements[index];\n        var priority = priorities[index];\n        while (index > startIndex) {\n            var parentIndex = this.getParentIndex_(index);\n            if (priorities[parentIndex] > priority) {\n                elements[index] = elements[parentIndex];\n                priorities[index] = priorities[parentIndex];\n                index = parentIndex;\n            }\n            else {\n                break;\n            }\n        }\n        elements[index] = element;\n        priorities[index] = priority;\n    };\n    /**\n     * FIXME empty description for jsdoc\n     */\n    PriorityQueue.prototype.reprioritize = function () {\n        var priorityFunction = this.priorityFunction_;\n        var elements = this.elements_;\n        var priorities = this.priorities_;\n        var index = 0;\n        var n = elements.length;\n        var element, i, priority;\n        for (i = 0; i < n; ++i) {\n            element = elements[i];\n            priority = priorityFunction(element);\n            if (priority == DROP) {\n                delete this.queuedElements_[this.keyFunction_(element)];\n            }\n            else {\n                priorities[index] = priority;\n                elements[index++] = element;\n            }\n        }\n        elements.length = index;\n        priorities.length = index;\n        this.heapify_();\n    };\n    return PriorityQueue;\n}());\nexport default PriorityQueue;\n//# sourceMappingURL=PriorityQueue.js.map"],"sourceRoot":""}
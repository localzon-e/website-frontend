{"version":3,"sources":["webpack:///./node_modules/ol/events/EventType.js","webpack:///./node_modules/ol/events/condition.js","webpack:///./node_modules/ol/dom.js","webpack:///./node_modules/ol/extent/Relationship.js","webpack:///./node_modules/ol/extent.js","webpack:///./node_modules/ol/events/Target.js","webpack:///./node_modules/ol/events/KeyCode.js","webpack:///./node_modules/ol/events.js","webpack:///./node_modules/ol/control/Control.js","webpack:///./node_modules/ol/control/Attribution.js","webpack:///./node_modules/ol/control/Rotate.js","webpack:///./node_modules/ol/control/Zoom.js","webpack:///./node_modules/ol/control.js","webpack:///./node_modules/ol/extent/Corner.js","webpack:///./node_modules/ol/functions.js","webpack:///./node_modules/ol/geom/GeometryLayout.js","webpack:///./node_modules/ol/geom/flat/transform.js","webpack:///./node_modules/ol/geom/Geometry.js","webpack:///./node_modules/ol/geom/SimpleGeometry.js","webpack:///./node_modules/ol/geom/flat/closest.js","webpack:///./node_modules/ol/geom/flat/deflate.js","webpack:///./node_modules/ol/geom/flat/simplify.js","webpack:///./node_modules/ol/geom/flat/inflate.js","webpack:///./node_modules/ol/geom/flat/area.js","webpack:///./node_modules/ol/geom/LinearRing.js","webpack:///./node_modules/ol/geom/Point.js","webpack:///./node_modules/ol/geom/flat/contains.js","webpack:///./node_modules/ol/geom/flat/interiorpoint.js","webpack:///./node_modules/ol/geom/flat/segments.js","webpack:///./node_modules/ol/geom/flat/intersectsextent.js","webpack:///./node_modules/ol/geom/flat/reverse.js","webpack:///./node_modules/ol/geom/flat/orient.js","webpack:///./node_modules/ol/geom/Polygon.js","webpack:///./node_modules/ol/color.js","webpack:///./node_modules/ol/centerconstraint.js","webpack:///./node_modules/ol/asserts.js","webpack:///./node_modules/ol/array.js","webpack:///./node_modules/ol/coordinate.js","webpack:///./node_modules/ol/easing.js","webpack:///./node_modules/ol/css.js","webpack:///./node_modules/ol/events/Event.js","webpack:///./node_modules/ol/geom/GeometryType.js"],"names":["CHANGE","ERROR","BLUR","CLEAR","CONTEXTMENU","CLICK","DBLCLICK","DRAGENTER","DRAGOVER","DROP","FOCUS","KEYDOWN","KEYPRESS","LOAD","RESIZE","TOUCHMOVE","WHEEL","all","var_args","conditions","arguments","event","pass","i","ii","length","altShiftKeysOnly","mapBrowserEvent","originalEvent","altKey","metaKey","ctrlKey","shiftKey","focus","target","getTargetElement","contains","document","activeElement","focusWithTabindex","map","hasAttribute","always","mouseActionButton","button","noModifierKeys","shiftKeyOnly","targetNotEditable","tagName","mouseOnly","pointerEvent","undefined","pointerType","primaryAction","isPrimary","createCanvasContext2D","opt_width","opt_height","opt_canvasPool","canvas","shift","OffscreenCanvas","createElement","width","height","getContext","replaceNode","newNode","oldNode","parent","parentNode","replaceChild","removeNode","node","removeChild","removeChildren","lastChild","replaceChildren","children","oldChildren","childNodes","oldChild","newChild","insertBefore","appendChild","UNKNOWN","INTERSECTING","ABOVE","RIGHT","BELOW","LEFT","boundingExtent","coordinates","extent","createEmpty","extendCoordinate","_boundingExtentXYs","xs","ys","opt_extent","minX","Math","min","apply","minY","maxX","max","maxY","createOrUpdate","clone","slice","closestSquaredDistanceXY","x","y","dx","dy","containsCoordinate","coordinate","containsXY","containsExtent","extent1","extent2","coordinateRelationship","relationship","Relationship","Infinity","createOrUpdateEmpty","createOrUpdateFromCoordinate","createOrUpdateFromCoordinates","extendCoordinates","createOrUpdateFromFlatCoordinates","flatCoordinates","offset","end","stride","extendFlatCoordinates","equals","extend","extendXY","forEachCorner","callback","val","getBottomLeft","getBottomRight","getTopRight","getTopLeft","getArea","area","isEmpty","getWidth","getHeight","getCenter","getCorner","corner","Corner","BOTTOM_LEFT","BOTTOM_RIGHT","TOP_LEFT","TOP_RIGHT","getForViewAndSize","center","resolution","rotation","size","cosRotation","cos","sinRotation","sin","xCos","xSin","yCos","ySin","x0","x1","x2","x3","y0","y1","y2","y3","getIntersection","intersection","returnOrUpdate","scaleFromCenter","value","deltaX","deltaY","intersectsSegment","start","intersects","startRel","endRel","startX","startY","endX","endY","slope","applyTransform","transformFn","opt_stops","push","l","__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__","this","constructor","create","Target","_super","opt_target","_this","eventTarget_","pendingRemovals_","dispatching_","listeners_","addEventListener","type","listener","listeners","listenersForType","indexOf","dispatchEvent","evt","propagate","dispatching","pendingRemovals","handleEvent","propagationStopped","pr","removeEventListener","disposeInternal","getListeners","hasListener","opt_type","keys","index","splice","UP","DOWN","listen","opt_this","opt_once","bind","originalListener_1","eventsKey","listenOnce","unlistenByKey","key","Control","options","element","style","pointerEvents","target_","map_","listenerKeys","render","setTarget","getMap","setMap","getOverlayContainerStopEvent","MapEventType","POSTRENDER","mapEvent","getElementById","Attribution","opt_options","ulElement_","collapsed_","collapsed","userCollapsed_","overrideCollapsible_","collapsible","collapsible_","className","tipLabel","expandClassName","collapseLabel","collapseClassName","collapseLabel_","textContent","label","label_","activeLabel","setAttribute","title","EventType","handleClick_","cssClasses","renderedAttributions_","renderedVisible_","collectSourceAttributions_","frameState","lookup","visibleAttributions","layerStatesArray","layerState","viewState","source","getSource","attributionGetter","getAttributions","attributions","getAttributionsCollapsible","isArray","j","jj","setCollapsible","updateElement_","visible","display","innerHTML","preventDefault","handleToggle_","classList","toggle","getCollapsible","setCollapsed","getCollapsed","Rotate","compassClassName","add","callResetNorth_","resetNorth","duration_","duration","autoHide_","autoHide","rotation_","resetNorth_","view","getView","getRotation","PI","animate","easing","setRotation","transform","remove","Zoom","delta","zoomInClassName","zoomOutClassName","zoomInLabel","zoomOutLabel","zoomInTipLabel","zoomOutTipLabel","inElement","createTextNode","outElement","zoomByDelta_","currentZoom","getZoom","newZoom","getConstrainedZoom","getAnimating","cancelAnimations","zoom","setZoom","defaults","controls","Collection","zoomControl","zoomOptions","rotateControl","rotate","rotateOptions","attributionControl","attribution","attributionOptions","TRUE","FALSE","VOID","memoizeOne","fn","lastResult","lastArgs","lastThis","called","nextArgs","XY","XYZ","XYM","XYZM","transform2D","opt_dest","dest","angle","anchor","anchorX","anchorY","k","sx","sy","translate","tmpTransform","Geometry","extent_","extentRevision_","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometryRevision","simplifyTransformedInternal","revision","squaredTolerance","opt_transform","getSimplifiedGeometry","simplifyTransformed","getRevision","closestPointXY","closestPoint","minSquaredDistance","coord","getClosestPoint","point","opt_closestPoint","NaN","intersectsCoordinate","computeExtent","getExtent","isNaN","scale","opt_sy","opt_anchor","simplify","tolerance","getType","intersectsExtent","destination","sourceProj","getUnits","Units","TILE_PIXELS","inCoordinates","outCoordinates","pixelExtent","projectedExtent","getWorldExtent","SimpleGeometry","layout","GeometryLayout","getCoordinates","getFirstCoordinate","getFlatCoordinates","getLastCoordinate","getLayout","simplifiedGeometry","getSimplifiedGeometryInternal","simplifiedFlatCoordinates","getStride","setFlatCoordinates","getStrideForLayout","setCoordinates","opt_layout","setLayout","nesting","getLayoutForStride","changed","assignClosest","offset1","offset2","t","maxSquaredDelta","squaredDelta","arrayMaxSquaredDelta","ends","assignClosestPoint","maxDelta","isRing","opt_tmpPoint","squaredDistance","tmpPoint","sqrt","assignClosestArrayPoint","deflateCoordinate","deflateCoordinates","deflateCoordinatesArray","coordinatess","opt_ends","douglasPeucker","simplifiedOffset","n","markers","stack","last","pop","first","maxSquaredDistance","squaredDistance_1","snap","round","quantize","dx1","dy1","dx2","dy2","quantizeArray","simplifiedEnds","inflateCoordinates","opt_coordinates","inflateCoordinatesArray","opt_coordinatess","twiceArea","LinearRing","maxDelta_","maxDeltaRevision_","GeometryType","LINEAR_RING","Point","applyProperties","POINT","linearRingContainsExtent","outside","linearRingContainsXY","wn","linearRingsContainsXY","getInteriorPointOfArray","flatCenters","flatCentersOffset","intersections","r","rr","pointX","maxSegmentLength","sort","segmentLength","abs","forEach","ret","point1","point2","intersectsLineString","coordinatesExtent","intersectsLinearRing","intersectsLinearRingArray","tmp","linearRingIsClockwise","edge","linearRingsAreOriented","opt_right","right","isClockwise","orientLinearRings","reverse","Polygon","ends_","flatInteriorPointRevision_","flatInteriorPoint_","orientedRevision_","orientedFlatCoordinates_","appendLinearRing","linearRing","polygon","getOrientedFlatCoordinates","getEnds","getFlatInteriorPoint","flatCenter","getInteriorPoint","getLinearRingCount","getLinearRing","getLinearRings","linearRings","POLYGON","fromExtent","HEX_COLOR_RE_","NAMED_COLOR_RE_","asString","color","toString","fromNamed","el","body","rgb","getComputedStyle","MAX_CACHE_SIZE","cache","cacheSize","fromStringInternal_","s","g","a","exec","hasAlpha","parseInt","substr","split","Number","normalize","createExtent","onlyCenter","smooth","opt_isMoving","opt_centerShift","viewWidth","viewHeight","shiftX","shiftY","ratio","log","none","assert","assertion","errorCode","numberSafeCompareFunction","linearFindNearest","arr","direction","data","extension","arr1","arr2","len1","isSorted","opt_func","opt_strict","compare","every","currentVal","res","coordinate1","coordinate2","cosAngle","sinAngle","wrapX","projection","canWrapX","worldWidth","worldsAway","getWorldsAway","opt_sourceExtentWidth","projectionExtent","sourceExtentWidth","floor","easeIn","pow","easeOut","inAndOut","linear","CLASS_HIDDEN","CLASS_UNSELECTABLE","CLASS_CONTROL","CLASS_COLLAPSED","fontRegEx","RegExp","join","fontRegExMatchIndex","getFontParameters","fontSpec","match","lineHeight","weight","variant","families","family","BaseEvent","stopPropagation","LINE_STRING","MULTI_POINT","MULTI_LINE_STRING","MULTI_POLYGON","GEOMETRY_COLLECTION","CIRCLE"],"mappings":"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","file":"js/chunk-vendors~bc04a12f.7ccadacf.js","sourcesContent":["/**\n * @module ol/events/EventType\n */\n/**\n * @enum {string}\n * @const\n */\nexport default {\n    /**\n     * Generic change event. Triggered when the revision counter is increased.\n     * @event module:ol/events/Event~BaseEvent#change\n     * @api\n     */\n    CHANGE: 'change',\n    /**\n     * Generic error event. Triggered when an error occurs.\n     * @event module:ol/events/Event~BaseEvent#error\n     * @api\n     */\n    ERROR: 'error',\n    BLUR: 'blur',\n    CLEAR: 'clear',\n    CONTEXTMENU: 'contextmenu',\n    CLICK: 'click',\n    DBLCLICK: 'dblclick',\n    DRAGENTER: 'dragenter',\n    DRAGOVER: 'dragover',\n    DROP: 'drop',\n    FOCUS: 'focus',\n    KEYDOWN: 'keydown',\n    KEYPRESS: 'keypress',\n    LOAD: 'load',\n    RESIZE: 'resize',\n    TOUCHMOVE: 'touchmove',\n    WHEEL: 'wheel',\n};\n//# sourceMappingURL=EventType.js.map","/**\n * @module ol/events/condition\n */\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport { FALSE, TRUE } from '../functions.js';\nimport { MAC, WEBKIT } from '../has.js';\nimport { assert } from '../asserts.js';\n/**\n * A function that takes an {@link module:ol/MapBrowserEvent} and returns a\n * `{boolean}`. If the condition is met, true should be returned.\n *\n * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default): boolean} Condition\n */\n/**\n * Creates a condition function that passes when all provided conditions pass.\n * @param {...Condition} var_args Conditions to check.\n * @return {Condition} Condition function.\n */\nexport function all(var_args) {\n    var conditions = arguments;\n    /**\n     * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n     * @return {boolean} All conditions passed.\n     */\n    return function (event) {\n        var pass = true;\n        for (var i = 0, ii = conditions.length; i < ii; ++i) {\n            pass = pass && conditions[i](event);\n            if (!pass) {\n                break;\n            }\n        }\n        return pass;\n    };\n}\n/**\n * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when\n * additionally the shift-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the alt key is pressed.\n * @api\n */\nexport var altKeyOnly = function (mapBrowserEvent) {\n    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);\n    return (originalEvent.altKey &&\n        !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n        !originalEvent.shiftKey);\n};\n/**\n * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise\n * (e.g. when additionally the platform-modifier-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the alt and shift keys are pressed.\n * @api\n */\nexport var altShiftKeysOnly = function (mapBrowserEvent) {\n    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);\n    return (originalEvent.altKey &&\n        !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n        originalEvent.shiftKey);\n};\n/**\n * Return `true` if the map has the focus. This condition requires a map target\n * element with a `tabindex` attribute, e.g. `<div id=\"map\" tabindex=\"1\">`.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n * @return {boolean} The map has the focus.\n * @api\n */\nexport var focus = function (event) {\n    return event.target.getTargetElement().contains(document.activeElement);\n};\n/**\n * Return `true` if the map has the focus or no 'tabindex' attribute set.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n * @return {boolean} The map container has the focus or no 'tabindex' attribute.\n */\nexport var focusWithTabindex = function (event) {\n    return event.map.getTargetElement().hasAttribute('tabindex')\n        ? focus(event)\n        : true;\n};\n/**\n * Return always true.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True.\n * @api\n */\nexport var always = TRUE;\n/**\n * Return `true` if the event is a `click` event, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `click` event.\n * @api\n */\nexport var click = function (mapBrowserEvent) {\n    return mapBrowserEvent.type == MapBrowserEventType.CLICK;\n};\n/**\n * Return `true` if the event has an \"action\"-producing mouse button.\n *\n * By definition, this includes left-click on windows/linux, and left-click\n * without the ctrl key on Macs.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} The result.\n */\nexport var mouseActionButton = function (mapBrowserEvent) {\n    var originalEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);\n    return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);\n};\n/**\n * Return always false.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} False.\n * @api\n */\nexport var never = FALSE;\n/**\n * Return `true` if the browser event is a `pointermove` event, `false`\n * otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the browser event is a `pointermove` event.\n * @api\n */\nexport var pointerMove = function (mapBrowserEvent) {\n    return mapBrowserEvent.type == 'pointermove';\n};\n/**\n * Return `true` if the event is a map `singleclick` event, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `singleclick` event.\n * @api\n */\nexport var singleClick = function (mapBrowserEvent) {\n    return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;\n};\n/**\n * Return `true` if the event is a map `dblclick` event, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `dblclick` event.\n * @api\n */\nexport var doubleClick = function (mapBrowserEvent) {\n    return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;\n};\n/**\n * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is\n * pressed.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True only if there no modifier keys are pressed.\n * @api\n */\nexport var noModifierKeys = function (mapBrowserEvent) {\n    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);\n    return (!originalEvent.altKey &&\n        !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n        !originalEvent.shiftKey);\n};\n/**\n * Return `true` if only the platform-modifier-key (the meta-key on Mac,\n * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally\n * the shift-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the platform modifier key is pressed.\n * @api\n */\nexport var platformModifierKeyOnly = function (mapBrowserEvent) {\n    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);\n    return (!originalEvent.altKey &&\n        (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&\n        !originalEvent.shiftKey);\n};\n/**\n * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when\n * additionally the alt-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the shift key is pressed.\n * @api\n */\nexport var shiftKeyOnly = function (mapBrowserEvent) {\n    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);\n    return (!originalEvent.altKey &&\n        !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n        originalEvent.shiftKey);\n};\n/**\n * Return `true` if the target element is not editable, i.e. not a `<input>`-,\n * `<select>`- or `<textarea>`-element, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True only if the target element is not editable.\n * @api\n */\nexport var targetNotEditable = function (mapBrowserEvent) {\n    var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);\n    var tagName = /** @type {Element} */ (originalEvent.target).tagName;\n    return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';\n};\n/**\n * Return `true` if the event originates from a mouse device.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a mouse device.\n * @api\n */\nexport var mouseOnly = function (mapBrowserEvent) {\n    var pointerEvent = /** @type {import(\"../MapBrowserEvent\").default} */ (mapBrowserEvent)\n        .originalEvent;\n    assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n    // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n    return pointerEvent.pointerType == 'mouse';\n};\n/**\n * Return `true` if the event originates from a touchable device.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a touchable device.\n * @api\n */\nexport var touchOnly = function (mapBrowserEvent) {\n    var pointerEvt = /** @type {import(\"../MapBrowserEvent\").default} */ (mapBrowserEvent)\n        .originalEvent;\n    assert(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n    // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n    return pointerEvt.pointerType === 'touch';\n};\n/**\n * Return `true` if the event originates from a digital pen.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a digital pen.\n * @api\n */\nexport var penOnly = function (mapBrowserEvent) {\n    var pointerEvt = /** @type {import(\"../MapBrowserEvent\").default} */ (mapBrowserEvent)\n        .originalEvent;\n    assert(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n    // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n    return pointerEvt.pointerType === 'pen';\n};\n/**\n * Return `true` if the event originates from a primary pointer in\n * contact with the surface or if the left mouse button is pressed.\n * See http://www.w3.org/TR/pointerevents/#button-states.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a primary pointer.\n * @api\n */\nexport var primaryAction = function (mapBrowserEvent) {\n    var pointerEvent = /** @type {import(\"../MapBrowserEvent\").default} */ (mapBrowserEvent)\n        .originalEvent;\n    assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n    return pointerEvent.isPrimary && pointerEvent.button === 0;\n};\n//# sourceMappingURL=condition.js.map","import { WORKER_OFFSCREEN_CANVAS } from './has.js';\n/**\n * @module ol/dom\n */\n//FIXME Move this function to the canvas module\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number=} opt_width Canvas width.\n * @param {number=} opt_height Canvas height.\n * @param {Array<HTMLCanvasElement>=} opt_canvasPool Canvas pool to take existing canvas from.\n * @return {CanvasRenderingContext2D} The context.\n */\nexport function createCanvasContext2D(opt_width, opt_height, opt_canvasPool) {\n    var canvas = opt_canvasPool && opt_canvasPool.length\n        ? opt_canvasPool.shift()\n        : WORKER_OFFSCREEN_CANVAS\n            ? new OffscreenCanvas(opt_width || 300, opt_height || 300)\n            : document.createElement('canvas');\n    if (opt_width) {\n        canvas.width = opt_width;\n    }\n    if (opt_height) {\n        canvas.height = opt_height;\n    }\n    //FIXME Allow OffscreenCanvasRenderingContext2D as return type\n    return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n}\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\nexport function outerWidth(element) {\n    var width = element.offsetWidth;\n    var style = getComputedStyle(element);\n    width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n    return width;\n}\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery's `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\nexport function outerHeight(element) {\n    var height = element.offsetHeight;\n    var style = getComputedStyle(element);\n    height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n    return height;\n}\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\nexport function replaceNode(newNode, oldNode) {\n    var parent = oldNode.parentNode;\n    if (parent) {\n        parent.replaceChild(newNode, oldNode);\n    }\n}\n/**\n * @param {Node} node The node to remove.\n * @returns {Node} The node that was removed or null.\n */\nexport function removeNode(node) {\n    return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n/**\n * @param {Node} node The node to remove the children from.\n */\nexport function removeChildren(node) {\n    while (node.lastChild) {\n        node.removeChild(node.lastChild);\n    }\n}\n/**\n * Transform the children of a parent node so they match the\n * provided list of children.  This function aims to efficiently\n * remove, add, and reorder child nodes while maintaining a simple\n * implementation (it is not guaranteed to minimize DOM operations).\n * @param {Node} node The parent node whose children need reworking.\n * @param {Array<Node>} children The desired children.\n */\nexport function replaceChildren(node, children) {\n    var oldChildren = node.childNodes;\n    for (var i = 0; true; ++i) {\n        var oldChild = oldChildren[i];\n        var newChild = children[i];\n        // check if our work is done\n        if (!oldChild && !newChild) {\n            break;\n        }\n        // check if children match\n        if (oldChild === newChild) {\n            continue;\n        }\n        // check if a new child needs to be added\n        if (!oldChild) {\n            node.appendChild(newChild);\n            continue;\n        }\n        // check if an old child needs to be removed\n        if (!newChild) {\n            node.removeChild(oldChild);\n            --i;\n            continue;\n        }\n        // reorder\n        node.insertBefore(newChild, oldChild);\n    }\n}\n//# sourceMappingURL=dom.js.map","/**\n * @module ol/extent/Relationship\n */\n/**\n * Relationship to an extent.\n * @enum {number}\n */\nexport default {\n    UNKNOWN: 0,\n    INTERSECTING: 1,\n    ABOVE: 2,\n    RIGHT: 4,\n    BELOW: 8,\n    LEFT: 16,\n};\n//# sourceMappingURL=Relationship.js.map","/**\n * @module ol/extent\n */\nimport Corner from './extent/Corner.js';\nimport Relationship from './extent/Relationship.js';\nimport { assert } from './asserts.js';\n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */\nexport function boundingExtent(coordinates) {\n    var extent = createEmpty();\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        extendCoordinate(extent, coordinates[i]);\n    }\n    return extent;\n}\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent=} opt_extent Destination extent.\n * @private\n * @return {Extent} Extent.\n */\nfunction _boundingExtentXYs(xs, ys, opt_extent) {\n    var minX = Math.min.apply(null, xs);\n    var minY = Math.min.apply(null, ys);\n    var maxX = Math.max.apply(null, xs);\n    var maxY = Math.max.apply(null, ys);\n    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n}\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n * @api\n */\nexport function buffer(extent, value, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = extent[0] - value;\n        opt_extent[1] = extent[1] - value;\n        opt_extent[2] = extent[2] + value;\n        opt_extent[3] = extent[3] + value;\n        return opt_extent;\n    }\n    else {\n        return [\n            extent[0] - value,\n            extent[1] - value,\n            extent[2] + value,\n            extent[3] + value,\n        ];\n    }\n}\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} The clone.\n */\nexport function clone(extent, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = extent[0];\n        opt_extent[1] = extent[1];\n        opt_extent[2] = extent[2];\n        opt_extent[3] = extent[3];\n        return opt_extent;\n    }\n    else {\n        return extent.slice();\n    }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\nexport function closestSquaredDistanceXY(extent, x, y) {\n    var dx, dy;\n    if (x < extent[0]) {\n        dx = extent[0] - x;\n    }\n    else if (extent[2] < x) {\n        dx = x - extent[2];\n    }\n    else {\n        dx = 0;\n    }\n    if (y < extent[1]) {\n        dy = extent[1] - y;\n    }\n    else if (extent[3] < y) {\n        dy = y - extent[3];\n    }\n    else {\n        dy = 0;\n    }\n    return dx * dx + dy * dy;\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\nexport function containsCoordinate(extent, coordinate) {\n    return containsXY(extent, coordinate[0], coordinate[1]);\n}\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\nexport function containsExtent(extent1, extent2) {\n    return (extent1[0] <= extent2[0] &&\n        extent2[2] <= extent1[2] &&\n        extent1[1] <= extent2[1] &&\n        extent2[3] <= extent1[3]);\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\nexport function containsXY(extent, x, y) {\n    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\n *     import(\"./extent/Relationship.js\").Relationship).\n */\nexport function coordinateRelationship(extent, coordinate) {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var x = coordinate[0];\n    var y = coordinate[1];\n    var relationship = Relationship.UNKNOWN;\n    if (x < minX) {\n        relationship = relationship | Relationship.LEFT;\n    }\n    else if (x > maxX) {\n        relationship = relationship | Relationship.RIGHT;\n    }\n    if (y < minY) {\n        relationship = relationship | Relationship.BELOW;\n    }\n    else if (y > maxY) {\n        relationship = relationship | Relationship.ABOVE;\n    }\n    if (relationship === Relationship.UNKNOWN) {\n        relationship = Relationship.INTERSECTING;\n    }\n    return relationship;\n}\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */\nexport function createEmpty() {\n    return [Infinity, Infinity, -Infinity, -Infinity];\n}\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent=} opt_extent Destination extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = minX;\n        opt_extent[1] = minY;\n        opt_extent[2] = maxX;\n        opt_extent[3] = maxY;\n        return opt_extent;\n    }\n    else {\n        return [minX, minY, maxX, maxY];\n    }\n}\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateEmpty(opt_extent) {\n    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinate(coordinate, opt_extent) {\n    var x = coordinate[0];\n    var y = coordinate[1];\n    return createOrUpdate(x, y, x, y, opt_extent);\n}\n/**\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinates(coordinates, opt_extent) {\n    var extent = createOrUpdateEmpty(opt_extent);\n    return extendCoordinates(extent, coordinates);\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {\n    var extent = createOrUpdateEmpty(opt_extent);\n    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n/**\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromRings(rings, opt_extent) {\n    var extent = createOrUpdateEmpty(opt_extent);\n    return extendRings(extent, rings);\n}\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\nexport function equals(extent1, extent2) {\n    return (extent1[0] == extent2[0] &&\n        extent1[2] == extent2[2] &&\n        extent1[1] == extent2[1] &&\n        extent1[3] == extent2[3]);\n}\n/**\n * Determine if two extents are approximately equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {number} tolerance Tolerance in extent coordinate units.\n * @return {boolean} The two extents differ by less than the tolerance.\n */\nexport function approximatelyEquals(extent1, extent2, tolerance) {\n    return (Math.abs(extent1[0] - extent2[0]) < tolerance &&\n        Math.abs(extent1[2] - extent2[2]) < tolerance &&\n        Math.abs(extent1[1] - extent2[1]) < tolerance &&\n        Math.abs(extent1[3] - extent2[3]) < tolerance);\n}\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */\nexport function extend(extent1, extent2) {\n    if (extent2[0] < extent1[0]) {\n        extent1[0] = extent2[0];\n    }\n    if (extent2[2] > extent1[2]) {\n        extent1[2] = extent2[2];\n    }\n    if (extent2[1] < extent1[1]) {\n        extent1[1] = extent2[1];\n    }\n    if (extent2[3] > extent1[3]) {\n        extent1[3] = extent2[3];\n    }\n    return extent1;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n */\nexport function extendCoordinate(extent, coordinate) {\n    if (coordinate[0] < extent[0]) {\n        extent[0] = coordinate[0];\n    }\n    if (coordinate[0] > extent[2]) {\n        extent[2] = coordinate[0];\n    }\n    if (coordinate[1] < extent[1]) {\n        extent[1] = coordinate[1];\n    }\n    if (coordinate[1] > extent[3]) {\n        extent[3] = coordinate[1];\n    }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */\nexport function extendCoordinates(extent, coordinates) {\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        extendCoordinate(extent, coordinates[i]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */\nexport function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {\n    for (; offset < end; offset += stride) {\n        extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */\nexport function extendRings(extent, rings) {\n    for (var i = 0, ii = rings.length; i < ii; ++i) {\n        extendCoordinates(extent, rings[i]);\n    }\n    return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\nexport function extendXY(extent, x, y) {\n    extent[0] = Math.min(extent[0], x);\n    extent[1] = Math.min(extent[1], y);\n    extent[2] = Math.max(extent[2], x);\n    extent[3] = Math.max(extent[3], y);\n}\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\n * @return {S|boolean} Value.\n * @template S\n */\nexport function forEachCorner(extent, callback) {\n    var val;\n    val = callback(getBottomLeft(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getBottomRight(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getTopRight(extent));\n    if (val) {\n        return val;\n    }\n    val = callback(getTopLeft(extent));\n    if (val) {\n        return val;\n    }\n    return false;\n}\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */\nexport function getArea(extent) {\n    var area = 0;\n    if (!isEmpty(extent)) {\n        area = getWidth(extent) * getHeight(extent);\n    }\n    return area;\n}\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n * @api\n */\nexport function getBottomLeft(extent) {\n    return [extent[0], extent[1]];\n}\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n * @api\n */\nexport function getBottomRight(extent) {\n    return [extent[2], extent[1]];\n}\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Center.\n * @api\n */\nexport function getCenter(extent) {\n    return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n}\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./extent/Corner.js\").default} corner Corner.\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n */\nexport function getCorner(extent, corner) {\n    var coordinate;\n    if (corner === Corner.BOTTOM_LEFT) {\n        coordinate = getBottomLeft(extent);\n    }\n    else if (corner === Corner.BOTTOM_RIGHT) {\n        coordinate = getBottomRight(extent);\n    }\n    else if (corner === Corner.TOP_LEFT) {\n        coordinate = getTopLeft(extent);\n    }\n    else if (corner === Corner.TOP_RIGHT) {\n        coordinate = getTopRight(extent);\n    }\n    else {\n        assert(false, 13); // Invalid corner\n    }\n    return coordinate;\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\nexport function getEnlargedArea(extent1, extent2) {\n    var minX = Math.min(extent1[0], extent2[0]);\n    var minY = Math.min(extent1[1], extent2[1]);\n    var maxX = Math.max(extent1[2], extent2[2]);\n    var maxY = Math.max(extent1[3], extent2[3]);\n    return (maxX - minX) * (maxY - minY);\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @param {Extent=} opt_extent Destination extent.\n * @return {Extent} Extent.\n */\nexport function getForViewAndSize(center, resolution, rotation, size, opt_extent) {\n    var dx = (resolution * size[0]) / 2;\n    var dy = (resolution * size[1]) / 2;\n    var cosRotation = Math.cos(rotation);\n    var sinRotation = Math.sin(rotation);\n    var xCos = dx * cosRotation;\n    var xSin = dx * sinRotation;\n    var yCos = dy * cosRotation;\n    var ySin = dy * sinRotation;\n    var x = center[0];\n    var y = center[1];\n    var x0 = x - xCos + ySin;\n    var x1 = x - xCos - ySin;\n    var x2 = x + xCos - ySin;\n    var x3 = x + xCos + ySin;\n    var y0 = y - xSin - yCos;\n    var y1 = y - xSin + yCos;\n    var y2 = y + xSin + yCos;\n    var y3 = y + xSin - yCos;\n    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);\n}\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\nexport function getHeight(extent) {\n    return extent[3] - extent[1];\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\nexport function getIntersectionArea(extent1, extent2) {\n    var intersection = getIntersection(extent1, extent2);\n    return getArea(intersection);\n}\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent=} opt_extent Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */\nexport function getIntersection(extent1, extent2, opt_extent) {\n    var intersection = opt_extent ? opt_extent : createEmpty();\n    if (intersects(extent1, extent2)) {\n        if (extent1[0] > extent2[0]) {\n            intersection[0] = extent1[0];\n        }\n        else {\n            intersection[0] = extent2[0];\n        }\n        if (extent1[1] > extent2[1]) {\n            intersection[1] = extent1[1];\n        }\n        else {\n            intersection[1] = extent2[1];\n        }\n        if (extent1[2] < extent2[2]) {\n            intersection[2] = extent1[2];\n        }\n        else {\n            intersection[2] = extent2[2];\n        }\n        if (extent1[3] < extent2[3]) {\n            intersection[3] = extent1[3];\n        }\n        else {\n            intersection[3] = extent2[3];\n        }\n    }\n    else {\n        createOrUpdateEmpty(intersection);\n    }\n    return intersection;\n}\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */\nexport function getMargin(extent) {\n    return getWidth(extent) + getHeight(extent);\n}\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import(\"./size.js\").Size} The extent size.\n * @api\n */\nexport function getSize(extent) {\n    return [extent[2] - extent[0], extent[3] - extent[1]];\n}\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n * @api\n */\nexport function getTopLeft(extent) {\n    return [extent[0], extent[3]];\n}\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n * @api\n */\nexport function getTopRight(extent) {\n    return [extent[2], extent[3]];\n}\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\nexport function getWidth(extent) {\n    return extent[2] - extent[0];\n}\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\nexport function intersects(extent1, extent2) {\n    return (extent1[0] <= extent2[2] &&\n        extent1[2] >= extent2[0] &&\n        extent1[1] <= extent2[3] &&\n        extent1[3] >= extent2[1]);\n}\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\nexport function isEmpty(extent) {\n    return extent[2] < extent[0] || extent[3] < extent[1];\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\nexport function returnOrUpdate(extent, opt_extent) {\n    if (opt_extent) {\n        opt_extent[0] = extent[0];\n        opt_extent[1] = extent[1];\n        opt_extent[2] = extent[2];\n        opt_extent[3] = extent[3];\n        return opt_extent;\n    }\n    else {\n        return extent;\n    }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */\nexport function scaleFromCenter(extent, value) {\n    var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\n    var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\n    extent[0] -= deltaX;\n    extent[2] += deltaX;\n    extent[1] -= deltaY;\n    extent[3] += deltaY;\n}\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\nexport function intersectsSegment(extent, start, end) {\n    var intersects = false;\n    var startRel = coordinateRelationship(extent, start);\n    var endRel = coordinateRelationship(extent, end);\n    if (startRel === Relationship.INTERSECTING ||\n        endRel === Relationship.INTERSECTING) {\n        intersects = true;\n    }\n    else {\n        var minX = extent[0];\n        var minY = extent[1];\n        var maxX = extent[2];\n        var maxY = extent[3];\n        var startX = start[0];\n        var startY = start[1];\n        var endX = end[0];\n        var endY = end[1];\n        var slope = (endY - startY) / (endX - startX);\n        var x = void 0, y = void 0;\n        if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n            // potentially intersects top\n            x = endX - (endY - maxY) / slope;\n            intersects = x >= minX && x <= maxX;\n        }\n        if (!intersects &&\n            !!(endRel & Relationship.RIGHT) &&\n            !(startRel & Relationship.RIGHT)) {\n            // potentially intersects right\n            y = endY - (endX - maxX) * slope;\n            intersects = y >= minY && y <= maxY;\n        }\n        if (!intersects &&\n            !!(endRel & Relationship.BELOW) &&\n            !(startRel & Relationship.BELOW)) {\n            // potentially intersects bottom\n            x = endX - (endY - minY) / slope;\n            intersects = x >= minX && x <= maxX;\n        }\n        if (!intersects &&\n            !!(endRel & Relationship.LEFT) &&\n            !(startRel & Relationship.LEFT)) {\n            // potentially intersects left\n            y = endY - (endX - minX) * slope;\n            intersects = y >= minY && y <= maxY;\n        }\n    }\n    return intersects;\n}\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent=} opt_extent Destination extent.\n * @param {number=} opt_stops Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {Extent} Extent.\n * @api\n */\nexport function applyTransform(extent, transformFn, opt_extent, opt_stops) {\n    var coordinates = [];\n    if (opt_stops > 1) {\n        var width = extent[2] - extent[0];\n        var height = extent[3] - extent[1];\n        for (var i = 0; i < opt_stops; ++i) {\n            coordinates.push(extent[0] + (width * i) / opt_stops, extent[1], extent[2], extent[1] + (height * i) / opt_stops, extent[2] - (width * i) / opt_stops, extent[3], extent[0], extent[3] - (height * i) / opt_stops);\n        }\n    }\n    else {\n        coordinates = [\n            extent[0],\n            extent[1],\n            extent[2],\n            extent[1],\n            extent[2],\n            extent[3],\n            extent[0],\n            extent[3],\n        ];\n    }\n    transformFn(coordinates, coordinates, 2);\n    var xs = [];\n    var ys = [];\n    for (var i = 0, l = coordinates.length; i < l; i += 2) {\n        xs.push(coordinates[i]);\n        ys.push(coordinates[i + 1]);\n    }\n    return _boundingExtentXYs(xs, ys, opt_extent);\n}\n/**\n * Modifies the provided extent in-place to be within the real world\n * extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Extent} The extent within the real world extent.\n */\nexport function wrapX(extent, projection) {\n    var projectionExtent = projection.getExtent();\n    var center = getCenter(extent);\n    if (projection.canWrapX() &&\n        (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {\n        var worldWidth = getWidth(projectionExtent);\n        var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);\n        var offset = worldsAway * worldWidth;\n        extent[0] -= offset;\n        extent[2] -= offset;\n    }\n    return extent;\n}\n//# sourceMappingURL=extent.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/events/Target\n */\nimport Disposable from '../Disposable.js';\nimport Event from './Event.js';\nimport { VOID } from '../functions.js';\nimport { clear } from '../obj.js';\n/**\n * @typedef {EventTarget|Target} EventTargetLike\n */\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n */\nvar Target = /** @class */ (function (_super) {\n    __extends(Target, _super);\n    /**\n     * @param {*=} opt_target Default event target for dispatched events.\n     */\n    function Target(opt_target) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {*}\n         */\n        _this.eventTarget_ = opt_target;\n        /**\n         * @private\n         * @type {Object<string, number>}\n         */\n        _this.pendingRemovals_ = null;\n        /**\n         * @private\n         * @type {Object<string, number>}\n         */\n        _this.dispatching_ = null;\n        /**\n         * @private\n         * @type {Object<string, Array<import(\"../events.js\").Listener>>}\n         */\n        _this.listeners_ = null;\n        return _this;\n    }\n    /**\n     * @param {string} type Type.\n     * @param {import(\"../events.js\").Listener} listener Listener.\n     */\n    Target.prototype.addEventListener = function (type, listener) {\n        if (!type || !listener) {\n            return;\n        }\n        var listeners = this.listeners_ || (this.listeners_ = {});\n        var listenersForType = listeners[type] || (listeners[type] = []);\n        if (listenersForType.indexOf(listener) === -1) {\n            listenersForType.push(listener);\n        }\n    };\n    /**\n     * Dispatches an event and calls all listeners listening for events\n     * of this type. The event parameter can either be a string or an\n     * Object with a `type` property.\n     *\n     * @param {import(\"./Event.js\").default|string} event Event object.\n     * @return {boolean|undefined} `false` if anyone called preventDefault on the\n     *     event object or if any of the listeners returned false.\n     * @api\n     */\n    Target.prototype.dispatchEvent = function (event) {\n        /** @type {import(\"./Event.js\").default|Event} */\n        var evt = typeof event === 'string' ? new Event(event) : event;\n        var type = evt.type;\n        if (!evt.target) {\n            evt.target = this.eventTarget_ || this;\n        }\n        var listeners = this.listeners_ && this.listeners_[type];\n        var propagate;\n        if (listeners) {\n            var dispatching = this.dispatching_ || (this.dispatching_ = {});\n            var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});\n            if (!(type in dispatching)) {\n                dispatching[type] = 0;\n                pendingRemovals[type] = 0;\n            }\n            ++dispatching[type];\n            for (var i = 0, ii = listeners.length; i < ii; ++i) {\n                if ('handleEvent' in listeners[i]) {\n                    propagate = /** @type {import(\"../events.js\").ListenerObject} */ (listeners[i]).handleEvent(evt);\n                }\n                else {\n                    propagate = /** @type {import(\"../events.js\").ListenerFunction} */ (listeners[i]).call(this, evt);\n                }\n                if (propagate === false || evt.propagationStopped) {\n                    propagate = false;\n                    break;\n                }\n            }\n            --dispatching[type];\n            if (dispatching[type] === 0) {\n                var pr = pendingRemovals[type];\n                delete pendingRemovals[type];\n                while (pr--) {\n                    this.removeEventListener(type, VOID);\n                }\n                delete dispatching[type];\n            }\n            return propagate;\n        }\n    };\n    /**\n     * Clean up.\n     */\n    Target.prototype.disposeInternal = function () {\n        this.listeners_ && clear(this.listeners_);\n    };\n    /**\n     * Get the listeners for a specified event type. Listeners are returned in the\n     * order that they will be called in.\n     *\n     * @param {string} type Type.\n     * @return {Array<import(\"../events.js\").Listener>|undefined} Listeners.\n     */\n    Target.prototype.getListeners = function (type) {\n        return (this.listeners_ && this.listeners_[type]) || undefined;\n    };\n    /**\n     * @param {string=} opt_type Type. If not provided,\n     *     `true` will be returned if this event target has any listeners.\n     * @return {boolean} Has listeners.\n     */\n    Target.prototype.hasListener = function (opt_type) {\n        if (!this.listeners_) {\n            return false;\n        }\n        return opt_type\n            ? opt_type in this.listeners_\n            : Object.keys(this.listeners_).length > 0;\n    };\n    /**\n     * @param {string} type Type.\n     * @param {import(\"../events.js\").Listener} listener Listener.\n     */\n    Target.prototype.removeEventListener = function (type, listener) {\n        var listeners = this.listeners_ && this.listeners_[type];\n        if (listeners) {\n            var index = listeners.indexOf(listener);\n            if (index !== -1) {\n                if (this.pendingRemovals_ && type in this.pendingRemovals_) {\n                    // make listener a no-op, and remove later in #dispatchEvent()\n                    listeners[index] = VOID;\n                    ++this.pendingRemovals_[type];\n                }\n                else {\n                    listeners.splice(index, 1);\n                    if (listeners.length === 0) {\n                        delete this.listeners_[type];\n                    }\n                }\n            }\n        }\n    };\n    return Target;\n}(Disposable));\nexport default Target;\n//# sourceMappingURL=Target.js.map","/**\n * @module ol/events/KeyCode\n */\n/**\n * @enum {number}\n * @const\n */\nexport default {\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n};\n//# sourceMappingURL=KeyCode.js.map","/**\n * @module ol/events\n */\nimport { clear } from './obj.js';\n/**\n * Key to use with {@link module:ol/Observable~Observable#unByKey}.\n * @typedef {Object} EventsKey\n * @property {ListenerFunction} listener\n * @property {import(\"./events/Target.js\").EventTargetLike} target\n * @property {string} type\n * @api\n */\n/**\n * Listener function. This function is called with an event object as argument.\n * When the function returns `false`, event propagation will stop.\n *\n * @typedef {function((Event|import(\"./events/Event.js\").default)): (void|boolean)} ListenerFunction\n * @api\n */\n/**\n * @typedef {Object} ListenerObject\n * @property {ListenerFunction} handleEvent\n */\n/**\n * @typedef {ListenerFunction|ListenerObject} Listener\n */\n/**\n * Registers an event listener on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * This function efficiently binds a `listener` to a `this` object, and returns\n * a key for use with {@link module:ol/events~unlistenByKey}.\n *\n * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ListenerFunction} listener Listener.\n * @param {Object=} opt_this Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n * @param {boolean=} opt_once If true, add the listener as one-off listener.\n * @return {EventsKey} Unique key for the listener.\n */\nexport function listen(target, type, listener, opt_this, opt_once) {\n    if (opt_this && opt_this !== target) {\n        listener = listener.bind(opt_this);\n    }\n    if (opt_once) {\n        var originalListener_1 = listener;\n        listener = function () {\n            target.removeEventListener(type, listener);\n            originalListener_1.apply(this, arguments);\n        };\n    }\n    var eventsKey = {\n        target: target,\n        type: type,\n        listener: listener,\n    };\n    target.addEventListener(type, listener);\n    return eventsKey;\n}\n/**\n * Registers a one-off event listener on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * This function efficiently binds a `listener` as self-unregistering listener\n * to a `this` object, and returns a key for use with\n * {@link module:ol/events~unlistenByKey} in case the listener needs to be\n * unregistered before it is called.\n *\n * When {@link module:ol/events~listen} is called with the same arguments after this\n * function, the self-unregistering listener will be turned into a permanent\n * listener.\n *\n * @param {import(\"./events/Target.js\").EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ListenerFunction} listener Listener.\n * @param {Object=} opt_this Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n * @return {EventsKey} Key for unlistenByKey.\n */\nexport function listenOnce(target, type, listener, opt_this) {\n    return listen(target, type, listener, opt_this, true);\n}\n/**\n * Unregisters event listeners on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * The argument passed to this function is the key returned from\n * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.\n *\n * @param {EventsKey} key The key.\n */\nexport function unlistenByKey(key) {\n    if (key && key.target) {\n        key.target.removeEventListener(key.type, key.listener);\n        clear(key);\n    }\n}\n//# sourceMappingURL=events.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/control/Control\n */\nimport BaseObject from '../Object.js';\nimport MapEventType from '../MapEventType.js';\nimport { VOID } from '../functions.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport { removeNode } from '../dom.js';\n/**\n * @typedef {Object} Options\n * @property {HTMLElement} [element] The element is the control's\n * container element. This only needs to be specified if you're developing\n * a custom control.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when\n * the control should be re-rendered. This is called in a `requestAnimationFrame`\n * callback.\n * @property {HTMLElement|string} [target] Specify a target if you want\n * the control to be rendered outside of the map's viewport.\n */\n/**\n * @classdesc\n * A control is a visible widget with a DOM element in a fixed position on the\n * screen. They can involve user input (buttons), or be informational only;\n * the position is determined using CSS. By default these are placed in the\n * container with CSS class name `ol-overlaycontainer-stopevent`, but can use\n * any outside DOM element.\n *\n * This is the base class for controls. You can use it for simple custom\n * controls by creating the element with listeners, creating an instance:\n * ```js\n * var myControl = new Control({element: myElement});\n * ```\n * and then adding this to the map.\n *\n * The main advantage of having this as a control rather than a simple separate\n * DOM element is that preventing propagation is handled for you. Controls\n * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.\n *\n * You can also extend this base for your own control class. See\n * examples/custom-controls for an example of how to do this.\n *\n * @api\n */\nvar Control = /** @class */ (function (_super) {\n    __extends(Control, _super);\n    /**\n     * @param {Options} options Control options.\n     */\n    function Control(options) {\n        var _this = _super.call(this) || this;\n        var element = options.element;\n        if (element && !options.target && !element.style.pointerEvents) {\n            element.style.pointerEvents = 'auto';\n        }\n        /**\n         * @protected\n         * @type {HTMLElement}\n         */\n        _this.element = element ? element : null;\n        /**\n         * @private\n         * @type {HTMLElement}\n         */\n        _this.target_ = null;\n        /**\n         * @private\n         * @type {import(\"../PluggableMap.js\").default}\n         */\n        _this.map_ = null;\n        /**\n         * @protected\n         * @type {!Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.listenerKeys = [];\n        if (options.render) {\n            _this.render = options.render;\n        }\n        if (options.target) {\n            _this.setTarget(options.target);\n        }\n        return _this;\n    }\n    /**\n     * Clean up.\n     */\n    Control.prototype.disposeInternal = function () {\n        removeNode(this.element);\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * Get the map associated with this control.\n     * @return {import(\"../PluggableMap.js\").default} Map.\n     * @api\n     */\n    Control.prototype.getMap = function () {\n        return this.map_;\n    };\n    /**\n     * Remove the control from its current map and attach it to the new map.\n     * Subclasses may set up event handlers to get notified about changes to\n     * the map here.\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     * @api\n     */\n    Control.prototype.setMap = function (map) {\n        if (this.map_) {\n            removeNode(this.element);\n        }\n        for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {\n            unlistenByKey(this.listenerKeys[i]);\n        }\n        this.listenerKeys.length = 0;\n        this.map_ = map;\n        if (this.map_) {\n            var target = this.target_\n                ? this.target_\n                : map.getOverlayContainerStopEvent();\n            target.appendChild(this.element);\n            if (this.render !== VOID) {\n                this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));\n            }\n            map.render();\n        }\n    };\n    /**\n     * Renders the control.\n     * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n     * @api\n     */\n    Control.prototype.render = function (mapEvent) { };\n    /**\n     * This function is used to set a target element for the control. It has no\n     * effect if it is called after the control has been added to the map (i.e.\n     * after `setMap` is called on the control). If no `target` is set in the\n     * options passed to the control constructor and if `setTarget` is not called\n     * then the control is added to the map's overlay container.\n     * @param {HTMLElement|string} target Target.\n     * @api\n     */\n    Control.prototype.setTarget = function (target) {\n        this.target_ =\n            typeof target === 'string' ? document.getElementById(target) : target;\n    };\n    return Control;\n}(BaseObject));\nexport default Control;\n//# sourceMappingURL=Control.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/control/Attribution\n */\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport { CLASS_COLLAPSED, CLASS_CONTROL, CLASS_UNSELECTABLE } from '../css.js';\nimport { equals } from '../array.js';\nimport { inView } from '../layer/Layer.js';\nimport { removeChildren, replaceNode } from '../dom.js';\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-attribution'] CSS class name.\n * @property {HTMLElement|string} [target] Specify a target if you\n * want the control to be rendered outside of the map's\n * viewport.\n * @property {boolean} [collapsible] Specify if attributions can\n * be collapsed. If not specified, sources control this behavior with their\n * `attributionsCollapsible` setting.\n * @property {boolean} [collapsed=true] Specify if attributions should\n * be collapsed at startup.\n * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.\n * @property {string} [label='i'] Text label to use for the\n * collapsed attributions button.\n * Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string} [expandClassName=className + '-expand'] CSS class name for the\n * collapsed attributions button.\n * @property {string|HTMLElement} [collapseLabel=''] Text label to use\n * for the expanded attributions button.\n * Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the\n * expanded attributions button.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when\n * the control should be re-rendered. This is called in a `requestAnimationFrame`\n * callback.\n */\n/**\n * @classdesc\n * Control to show all the attributions associated with the layer sources\n * in the map. This control is one of the default controls included in maps.\n * By default it will show in the bottom right portion of the map, but this can\n * be changed by using a css selector for `.ol-attribution`.\n *\n * @api\n */\nvar Attribution = /** @class */ (function (_super) {\n    __extends(Attribution, _super);\n    /**\n     * @param {Options=} opt_options Attribution options.\n     */\n    function Attribution(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        _this = _super.call(this, {\n            element: document.createElement('div'),\n            render: options.render,\n            target: options.target,\n        }) || this;\n        /**\n         * @private\n         * @type {HTMLElement}\n         */\n        _this.ulElement_ = document.createElement('ul');\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.collapsed_ =\n            options.collapsed !== undefined ? options.collapsed : true;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.userCollapsed_ = _this.collapsed_;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.overrideCollapsible_ = options.collapsible !== undefined;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.collapsible_ =\n            options.collapsible !== undefined ? options.collapsible : true;\n        if (!_this.collapsible_) {\n            _this.collapsed_ = false;\n        }\n        var className = options.className !== undefined ? options.className : 'ol-attribution';\n        var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';\n        var expandClassName = options.expandClassName !== undefined\n            ? options.expandClassName\n            : className + '-expand';\n        var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\\u00BB';\n        var collapseClassName = options.collapseClassName !== undefined\n            ? options.collapseClassName\n            : className + '-collpase';\n        if (typeof collapseLabel === 'string') {\n            /**\n             * @private\n             * @type {HTMLElement}\n             */\n            _this.collapseLabel_ = document.createElement('span');\n            _this.collapseLabel_.textContent = collapseLabel;\n            _this.collapseLabel_.className = collapseClassName;\n        }\n        else {\n            _this.collapseLabel_ = collapseLabel;\n        }\n        var label = options.label !== undefined ? options.label : 'i';\n        if (typeof label === 'string') {\n            /**\n             * @private\n             * @type {HTMLElement}\n             */\n            _this.label_ = document.createElement('span');\n            _this.label_.textContent = label;\n            _this.label_.className = expandClassName;\n        }\n        else {\n            _this.label_ = label;\n        }\n        var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;\n        var button = document.createElement('button');\n        button.setAttribute('type', 'button');\n        button.title = tipLabel;\n        button.appendChild(activeLabel);\n        button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);\n        var cssClasses = className +\n            ' ' +\n            CLASS_UNSELECTABLE +\n            ' ' +\n            CLASS_CONTROL +\n            (_this.collapsed_ && _this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') +\n            (_this.collapsible_ ? '' : ' ol-uncollapsible');\n        var element = _this.element;\n        element.className = cssClasses;\n        element.appendChild(_this.ulElement_);\n        element.appendChild(button);\n        /**\n         * A list of currently rendered resolutions.\n         * @type {Array<string>}\n         * @private\n         */\n        _this.renderedAttributions_ = [];\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.renderedVisible_ = true;\n        return _this;\n    }\n    /**\n     * Collect a list of visible attributions and set the collapsible state.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {Array<string>} Attributions.\n     * @private\n     */\n    Attribution.prototype.collectSourceAttributions_ = function (frameState) {\n        /**\n         * Used to determine if an attribution already exists.\n         * @type {!Object<string, boolean>}\n         */\n        var lookup = {};\n        /**\n         * A list of visible attributions.\n         * @type {Array<string>}\n         */\n        var visibleAttributions = [];\n        var collapsible = true;\n        var layerStatesArray = frameState.layerStatesArray;\n        for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n            var layerState = layerStatesArray[i];\n            if (!inView(layerState, frameState.viewState)) {\n                continue;\n            }\n            var source = /** @type {import(\"../layer/Layer.js\").default} */ (layerState.layer).getSource();\n            if (!source) {\n                continue;\n            }\n            var attributionGetter = source.getAttributions();\n            if (!attributionGetter) {\n                continue;\n            }\n            var attributions = attributionGetter(frameState);\n            if (!attributions) {\n                continue;\n            }\n            collapsible =\n                collapsible && source.getAttributionsCollapsible() !== false;\n            if (Array.isArray(attributions)) {\n                for (var j = 0, jj = attributions.length; j < jj; ++j) {\n                    if (!(attributions[j] in lookup)) {\n                        visibleAttributions.push(attributions[j]);\n                        lookup[attributions[j]] = true;\n                    }\n                }\n            }\n            else {\n                if (!(attributions in lookup)) {\n                    visibleAttributions.push(attributions);\n                    lookup[attributions] = true;\n                }\n            }\n        }\n        if (!this.overrideCollapsible_) {\n            this.setCollapsible(collapsible);\n        }\n        return visibleAttributions;\n    };\n    /**\n     * @private\n     * @param {?import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     */\n    Attribution.prototype.updateElement_ = function (frameState) {\n        if (!frameState) {\n            if (this.renderedVisible_) {\n                this.element.style.display = 'none';\n                this.renderedVisible_ = false;\n            }\n            return;\n        }\n        var attributions = this.collectSourceAttributions_(frameState);\n        var visible = attributions.length > 0;\n        if (this.renderedVisible_ != visible) {\n            this.element.style.display = visible ? '' : 'none';\n            this.renderedVisible_ = visible;\n        }\n        if (equals(attributions, this.renderedAttributions_)) {\n            return;\n        }\n        removeChildren(this.ulElement_);\n        // append the attributions\n        for (var i = 0, ii = attributions.length; i < ii; ++i) {\n            var element = document.createElement('li');\n            element.innerHTML = attributions[i];\n            this.ulElement_.appendChild(element);\n        }\n        this.renderedAttributions_ = attributions;\n    };\n    /**\n     * @param {MouseEvent} event The event to handle\n     * @private\n     */\n    Attribution.prototype.handleClick_ = function (event) {\n        event.preventDefault();\n        this.handleToggle_();\n        this.userCollapsed_ = this.collapsed_;\n    };\n    /**\n     * @private\n     */\n    Attribution.prototype.handleToggle_ = function () {\n        this.element.classList.toggle(CLASS_COLLAPSED);\n        if (this.collapsed_) {\n            replaceNode(this.collapseLabel_, this.label_);\n        }\n        else {\n            replaceNode(this.label_, this.collapseLabel_);\n        }\n        this.collapsed_ = !this.collapsed_;\n    };\n    /**\n     * Return `true` if the attribution is collapsible, `false` otherwise.\n     * @return {boolean} True if the widget is collapsible.\n     * @api\n     */\n    Attribution.prototype.getCollapsible = function () {\n        return this.collapsible_;\n    };\n    /**\n     * Set whether the attribution should be collapsible.\n     * @param {boolean} collapsible True if the widget is collapsible.\n     * @api\n     */\n    Attribution.prototype.setCollapsible = function (collapsible) {\n        if (this.collapsible_ === collapsible) {\n            return;\n        }\n        this.collapsible_ = collapsible;\n        this.element.classList.toggle('ol-uncollapsible');\n        if (this.userCollapsed_) {\n            this.handleToggle_();\n        }\n    };\n    /**\n     * Collapse or expand the attribution according to the passed parameter. Will\n     * not do anything if the attribution isn't collapsible or if the current\n     * collapsed state is already the one requested.\n     * @param {boolean} collapsed True if the widget is collapsed.\n     * @api\n     */\n    Attribution.prototype.setCollapsed = function (collapsed) {\n        this.userCollapsed_ = collapsed;\n        if (!this.collapsible_ || this.collapsed_ === collapsed) {\n            return;\n        }\n        this.handleToggle_();\n    };\n    /**\n     * Return `true` when the attribution is currently collapsed or `false`\n     * otherwise.\n     * @return {boolean} True if the widget is collapsed.\n     * @api\n     */\n    Attribution.prototype.getCollapsed = function () {\n        return this.collapsed_;\n    };\n    /**\n     * Update the attribution element.\n     * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n     * @override\n     */\n    Attribution.prototype.render = function (mapEvent) {\n        this.updateElement_(mapEvent.frameState);\n    };\n    return Attribution;\n}(Control));\nexport default Attribution;\n//# sourceMappingURL=Attribution.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/control/Rotate\n */\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport { CLASS_CONTROL, CLASS_HIDDEN, CLASS_UNSELECTABLE } from '../css.js';\nimport { easeOut } from '../easing.js';\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-rotate'] CSS class name.\n * @property {string|HTMLElement} [label=''] Text label to use for the rotate button.\n * Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.\n * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {boolean} [autoHide=true] Hide the control when rotation is 0.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when the control should\n * be re-rendered. This is called in a `requestAnimationFrame` callback.\n * @property {function():void} [resetNorth] Function called when the control is clicked.\n * This will override the default `resetNorth`.\n * @property {HTMLElement|string} [target] Specify a target if you want the control to be\n * rendered outside of the map's viewport.\n */\n/**\n * @classdesc\n * A button control to reset rotation to 0.\n * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css\n * selector is added to the button when the rotation is 0.\n *\n * @api\n */\nvar Rotate = /** @class */ (function (_super) {\n    __extends(Rotate, _super);\n    /**\n     * @param {Options=} opt_options Rotate options.\n     */\n    function Rotate(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        _this = _super.call(this, {\n            element: document.createElement('div'),\n            render: options.render,\n            target: options.target,\n        }) || this;\n        var className = options.className !== undefined ? options.className : 'ol-rotate';\n        var label = options.label !== undefined ? options.label : '\\u21E7';\n        var compassClassName = options.compassClassName !== undefined\n            ? options.compassClassName\n            : 'ol-compass';\n        /**\n         * @type {HTMLElement}\n         * @private\n         */\n        _this.label_ = null;\n        if (typeof label === 'string') {\n            _this.label_ = document.createElement('span');\n            _this.label_.className = compassClassName;\n            _this.label_.textContent = label;\n        }\n        else {\n            _this.label_ = label;\n            _this.label_.classList.add(compassClassName);\n        }\n        var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';\n        var button = document.createElement('button');\n        button.className = className + '-reset';\n        button.setAttribute('type', 'button');\n        button.title = tipLabel;\n        button.appendChild(_this.label_);\n        button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);\n        var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n        var element = _this.element;\n        element.className = cssClasses;\n        element.appendChild(button);\n        _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.duration_ = options.duration !== undefined ? options.duration : 250;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        _this.rotation_ = undefined;\n        if (_this.autoHide_) {\n            _this.element.classList.add(CLASS_HIDDEN);\n        }\n        return _this;\n    }\n    /**\n     * @param {MouseEvent} event The event to handle\n     * @private\n     */\n    Rotate.prototype.handleClick_ = function (event) {\n        event.preventDefault();\n        if (this.callResetNorth_ !== undefined) {\n            this.callResetNorth_();\n        }\n        else {\n            this.resetNorth_();\n        }\n    };\n    /**\n     * @private\n     */\n    Rotate.prototype.resetNorth_ = function () {\n        var map = this.getMap();\n        var view = map.getView();\n        if (!view) {\n            // the map does not have a view, so we can't act\n            // upon it\n            return;\n        }\n        var rotation = view.getRotation();\n        if (rotation !== undefined) {\n            if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {\n                view.animate({\n                    rotation: 0,\n                    duration: this.duration_,\n                    easing: easeOut,\n                });\n            }\n            else {\n                view.setRotation(0);\n            }\n        }\n    };\n    /**\n     * Update the rotate control element.\n     * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n     * @override\n     */\n    Rotate.prototype.render = function (mapEvent) {\n        var frameState = mapEvent.frameState;\n        if (!frameState) {\n            return;\n        }\n        var rotation = frameState.viewState.rotation;\n        if (rotation != this.rotation_) {\n            var transform = 'rotate(' + rotation + 'rad)';\n            if (this.autoHide_) {\n                var contains = this.element.classList.contains(CLASS_HIDDEN);\n                if (!contains && rotation === 0) {\n                    this.element.classList.add(CLASS_HIDDEN);\n                }\n                else if (contains && rotation !== 0) {\n                    this.element.classList.remove(CLASS_HIDDEN);\n                }\n            }\n            this.label_.style.transform = transform;\n        }\n        this.rotation_ = rotation;\n    };\n    return Rotate;\n}(Control));\nexport default Rotate;\n//# sourceMappingURL=Rotate.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/control/Zoom\n */\nimport Control from './Control.js';\nimport EventType from '../events/EventType.js';\nimport { CLASS_CONTROL, CLASS_UNSELECTABLE } from '../css.js';\nimport { easeOut } from '../easing.js';\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {string} [className='ol-zoom'] CSS class name.\n * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.\n * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.\n * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in\n * button. Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.\n * Instead of text, also an element (e.g. a `span` element) can be used.\n * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.\n * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.\n * @property {number} [delta=1] The zoom delta applied on each click.\n * @property {HTMLElement|string} [target] Specify a target if you want the control to be\n * rendered outside of the map's viewport.\n */\n/**\n * @classdesc\n * A control with 2 buttons, one for zoom in and one for zoom out.\n * This control is one of the default controls of a map. To style this control\n * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.\n *\n * @api\n */\nvar Zoom = /** @class */ (function (_super) {\n    __extends(Zoom, _super);\n    /**\n     * @param {Options=} opt_options Zoom options.\n     */\n    function Zoom(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        _this = _super.call(this, {\n            element: document.createElement('div'),\n            target: options.target,\n        }) || this;\n        var className = options.className !== undefined ? options.className : 'ol-zoom';\n        var delta = options.delta !== undefined ? options.delta : 1;\n        var zoomInClassName = options.zoomInClassName !== undefined\n            ? options.zoomInClassName\n            : className + '-in';\n        var zoomOutClassName = options.zoomOutClassName !== undefined\n            ? options.zoomOutClassName\n            : className + '-out';\n        var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';\n        var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\\u2212';\n        var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';\n        var zoomOutTipLabel = options.zoomOutTipLabel !== undefined\n            ? options.zoomOutTipLabel\n            : 'Zoom out';\n        var inElement = document.createElement('button');\n        inElement.className = zoomInClassName;\n        inElement.setAttribute('type', 'button');\n        inElement.title = zoomInTipLabel;\n        inElement.appendChild(typeof zoomInLabel === 'string'\n            ? document.createTextNode(zoomInLabel)\n            : zoomInLabel);\n        inElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, delta), false);\n        var outElement = document.createElement('button');\n        outElement.className = zoomOutClassName;\n        outElement.setAttribute('type', 'button');\n        outElement.title = zoomOutTipLabel;\n        outElement.appendChild(typeof zoomOutLabel === 'string'\n            ? document.createTextNode(zoomOutLabel)\n            : zoomOutLabel);\n        outElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, -delta), false);\n        var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n        var element = _this.element;\n        element.className = cssClasses;\n        element.appendChild(inElement);\n        element.appendChild(outElement);\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.duration_ = options.duration !== undefined ? options.duration : 250;\n        return _this;\n    }\n    /**\n     * @param {number} delta Zoom delta.\n     * @param {MouseEvent} event The event to handle\n     * @private\n     */\n    Zoom.prototype.handleClick_ = function (delta, event) {\n        event.preventDefault();\n        this.zoomByDelta_(delta);\n    };\n    /**\n     * @param {number} delta Zoom delta.\n     * @private\n     */\n    Zoom.prototype.zoomByDelta_ = function (delta) {\n        var map = this.getMap();\n        var view = map.getView();\n        if (!view) {\n            // the map does not have a view, so we can't act\n            // upon it\n            return;\n        }\n        var currentZoom = view.getZoom();\n        if (currentZoom !== undefined) {\n            var newZoom = view.getConstrainedZoom(currentZoom + delta);\n            if (this.duration_ > 0) {\n                if (view.getAnimating()) {\n                    view.cancelAnimations();\n                }\n                view.animate({\n                    zoom: newZoom,\n                    duration: this.duration_,\n                    easing: easeOut,\n                });\n            }\n            else {\n                view.setZoom(newZoom);\n            }\n        }\n    };\n    return Zoom;\n}(Control));\nexport default Zoom;\n//# sourceMappingURL=Zoom.js.map","/**\n * @module ol/control\n */\nimport Attribution from './control/Attribution.js';\nimport Collection from './Collection.js';\nimport Rotate from './control/Rotate.js';\nimport Zoom from './control/Zoom.js';\nexport { default as Attribution } from './control/Attribution.js';\nexport { default as Control } from './control/Control.js';\nexport { default as FullScreen } from './control/FullScreen.js';\nexport { default as MousePosition } from './control/MousePosition.js';\nexport { default as OverviewMap } from './control/OverviewMap.js';\nexport { default as Rotate } from './control/Rotate.js';\nexport { default as ScaleLine } from './control/ScaleLine.js';\nexport { default as Zoom } from './control/Zoom.js';\nexport { default as ZoomSlider } from './control/ZoomSlider.js';\nexport { default as ZoomToExtent } from './control/ZoomToExtent.js';\n/**\n * @typedef {Object} DefaultsOptions\n * @property {boolean} [attribution=true] Include\n * {@link module:ol/control/Attribution~Attribution}.\n * @property {import(\"./control/Attribution.js\").Options} [attributionOptions]\n * Options for {@link module:ol/control/Attribution~Attribution}.\n * @property {boolean} [rotate=true] Include\n * {@link module:ol/control/Rotate~Rotate}.\n * @property {import(\"./control/Rotate.js\").Options} [rotateOptions] Options\n * for {@link module:ol/control/Rotate~Rotate}.\n * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.\n * @property {import(\"./control/Zoom.js\").Options} [zoomOptions] Options for\n * {@link module:ol/control/Zoom~Zoom}.\n * @api\n */\n/**\n * Set of controls included in maps by default. Unless configured otherwise,\n * this returns a collection containing an instance of each of the following\n * controls:\n * * {@link module:ol/control/Zoom~Zoom}\n * * {@link module:ol/control/Rotate~Rotate}\n * * {@link module:ol/control/Attribution~Attribution}\n *\n * @param {DefaultsOptions=} opt_options\n * Defaults options.\n * @return {Collection<import(\"./control/Control.js\").default>}\n * Controls.\n * @api\n */\nexport function defaults(opt_options) {\n    var options = opt_options ? opt_options : {};\n    var controls = new Collection();\n    var zoomControl = options.zoom !== undefined ? options.zoom : true;\n    if (zoomControl) {\n        controls.push(new Zoom(options.zoomOptions));\n    }\n    var rotateControl = options.rotate !== undefined ? options.rotate : true;\n    if (rotateControl) {\n        controls.push(new Rotate(options.rotateOptions));\n    }\n    var attributionControl = options.attribution !== undefined ? options.attribution : true;\n    if (attributionControl) {\n        controls.push(new Attribution(options.attributionOptions));\n    }\n    return controls;\n}\n//# sourceMappingURL=control.js.map","/**\n * @module ol/extent/Corner\n */\n/**\n * Extent corner.\n * @enum {string}\n */\nexport default {\n    BOTTOM_LEFT: 'bottom-left',\n    BOTTOM_RIGHT: 'bottom-right',\n    TOP_LEFT: 'top-left',\n    TOP_RIGHT: 'top-right',\n};\n//# sourceMappingURL=Corner.js.map","/**\n * @module ol/functions\n */\nimport { equals as arrayEquals } from './array.js';\n/**\n * Always returns true.\n * @returns {boolean} true.\n */\nexport function TRUE() {\n    return true;\n}\n/**\n * Always returns false.\n * @returns {boolean} false.\n */\nexport function FALSE() {\n    return false;\n}\n/**\n * A reusable function, used e.g. as a default for callbacks.\n *\n * @return {void} Nothing.\n */\nexport function VOID() { }\n/**\n * Wrap a function in another function that remembers the last return.  If the\n * returned function is called twice in a row with the same arguments and the same\n * this object, it will return the value from the first call in the second call.\n *\n * @param {function(...any): ReturnType} fn The function to memoize.\n * @return {function(...any): ReturnType} The memoized function.\n * @template ReturnType\n */\nexport function memoizeOne(fn) {\n    var called = false;\n    /** @type {ReturnType} */\n    var lastResult;\n    /** @type {Array<any>} */\n    var lastArgs;\n    var lastThis;\n    return function () {\n        var nextArgs = Array.prototype.slice.call(arguments);\n        if (!called || this !== lastThis || !arrayEquals(nextArgs, lastArgs)) {\n            called = true;\n            lastThis = this;\n            lastArgs = nextArgs;\n            lastResult = fn.apply(this, arguments);\n        }\n        return lastResult;\n    };\n}\n//# sourceMappingURL=functions.js.map","/**\n * @module ol/geom/GeometryLayout\n */\n/**\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available. Supported values are `'XY'`,\n * `'XYZ'`, `'XYM'`, `'XYZM'`.\n * @enum {string}\n */\nexport default {\n    XY: 'XY',\n    XYZ: 'XYZ',\n    XYM: 'XYM',\n    XYZM: 'XYZM',\n};\n//# sourceMappingURL=GeometryLayout.js.map","/**\n * @module ol/geom/flat/transform\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../transform.js\").Transform} transform Transform.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        var x = flatCoordinates[j];\n        var y = flatCoordinates[j + 1];\n        dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n        dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} angle Angle.\n * @param {Array<number>} anchor Rotation anchor point.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    var anchorX = anchor[0];\n    var anchorY = anchor[1];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        var deltaX = flatCoordinates[j] - anchorX;\n        var deltaY = flatCoordinates[j + 1] - anchorY;\n        dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n        dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n        for (var k = j + 2; k < j + stride; ++k) {\n            dest[i++] = flatCoordinates[k];\n        }\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n/**\n * Scale the coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} sx Scale factor in the x-direction.\n * @param {number} sy Scale factor in the y-direction.\n * @param {Array<number>} anchor Scale anchor point.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var anchorX = anchor[0];\n    var anchorY = anchor[1];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        var deltaX = flatCoordinates[j] - anchorX;\n        var deltaY = flatCoordinates[j + 1] - anchorY;\n        dest[i++] = anchorX + sx * deltaX;\n        dest[i++] = anchorY + sy * deltaY;\n        for (var k = j + 2; k < j + stride; ++k) {\n            dest[i++] = flatCoordinates[k];\n        }\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {\n    var dest = opt_dest ? opt_dest : [];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        dest[i++] = flatCoordinates[j] + deltaX;\n        dest[i++] = flatCoordinates[j + 1] + deltaY;\n        for (var k = j + 2; k < j + stride; ++k) {\n            dest[i++] = flatCoordinates[k];\n        }\n    }\n    if (opt_dest && dest.length != i) {\n        dest.length = i;\n    }\n    return dest;\n}\n//# sourceMappingURL=transform.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Geometry\n */\nimport BaseObject from '../Object.js';\nimport Units from '../proj/Units.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, create as createTransform, } from '../transform.js';\nimport { createEmpty, createOrUpdateEmpty, getHeight, returnOrUpdate, } from '../extent.js';\nimport { get as getProjection, getTransform } from '../proj.js';\nimport { memoizeOne } from '../functions.js';\nimport { transform2D } from './flat/transform.js';\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nvar Geometry = /** @class */ (function (_super) {\n    __extends(Geometry, _super);\n    function Geometry() {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {import(\"../extent.js\").Extent}\n         */\n        _this.extent_ = createEmpty();\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.extentRevision_ = -1;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.simplifiedGeometryRevision = 0;\n        /**\n         * Get a transformed and simplified version of the geometry.\n         * @abstract\n         * @param {number} revision The geometry revision.\n         * @param {number} squaredTolerance Squared tolerance.\n         * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n         * @return {Geometry} Simplified geometry.\n         */\n        _this.simplifyTransformedInternal = memoizeOne(function (revision, squaredTolerance, opt_transform) {\n            if (!opt_transform) {\n                return this.getSimplifiedGeometry(squaredTolerance);\n            }\n            var clone = this.clone();\n            clone.applyTransform(opt_transform);\n            return clone.getSimplifiedGeometry(squaredTolerance);\n        });\n        return _this;\n    }\n    /**\n     * Get a transformed and simplified version of the geometry.\n     * @abstract\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../proj.js\").TransformFunction} [opt_transform] Optional transform function.\n     * @return {Geometry} Simplified geometry.\n     */\n    Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {\n        return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @abstract\n     * @return {!Geometry} Clone.\n     */\n    Geometry.prototype.clone = function () {\n        return abstract();\n    };\n    /**\n     * @abstract\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        return abstract();\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Geometry.prototype.containsXY = function (x, y) {\n        var coord = this.getClosestPoint([x, y]);\n        return coord[0] === x && coord[1] === y;\n    };\n    /**\n     * Return the closest point of the geometry to the passed point as\n     * {@link module:ol/coordinate~Coordinate coordinate}.\n     * @param {import(\"../coordinate.js\").Coordinate} point Point.\n     * @param {import(\"../coordinate.js\").Coordinate=} opt_closestPoint Closest point.\n     * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n     * @api\n     */\n    Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {\n        var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n        this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n        return closestPoint;\n    };\n    /**\n     * Returns true if this geometry includes the specified coordinate. If the\n     * coordinate is on the boundary of the geometry, returns false.\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains coordinate.\n     * @api\n     */\n    Geometry.prototype.intersectsCoordinate = function (coordinate) {\n        return this.containsXY(coordinate[0], coordinate[1]);\n    };\n    /**\n     * @abstract\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    Geometry.prototype.computeExtent = function (extent) {\n        return abstract();\n    };\n    /**\n     * Get the extent of the geometry.\n     * @param {import(\"../extent.js\").Extent=} opt_extent Extent.\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     * @api\n     */\n    Geometry.prototype.getExtent = function (opt_extent) {\n        if (this.extentRevision_ != this.getRevision()) {\n            var extent = this.computeExtent(this.extent_);\n            if (isNaN(extent[0]) || isNaN(extent[1])) {\n                createOrUpdateEmpty(extent);\n            }\n            this.extentRevision_ = this.getRevision();\n        }\n        return returnOrUpdate(this.extent_, opt_extent);\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @abstract\n     * @param {number} angle Rotation angle in radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    Geometry.prototype.rotate = function (angle, anchor) {\n        abstract();\n    };\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @abstract\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n    Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {\n        abstract();\n    };\n    /**\n     * Create a simplified version of this geometry.  For linestrings, this uses\n     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)\n     * algorithm.  For polygons, a quantization-based\n     * simplification is used to preserve topology.\n     * @param {number} tolerance The tolerance distance for simplification.\n     * @return {Geometry} A new, simplified version of the original geometry.\n     * @api\n     */\n    Geometry.prototype.simplify = function (tolerance) {\n        return this.getSimplifiedGeometry(tolerance * tolerance);\n    };\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker\n     * algorithm.\n     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n     * @abstract\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {Geometry} Simplified geometry.\n     */\n    Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n        return abstract();\n    };\n    /**\n     * Get the type of this geometry.\n     * @abstract\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     */\n    Geometry.prototype.getType = function () {\n        return abstract();\n    };\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @abstract\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     */\n    Geometry.prototype.applyTransform = function (transformFn) {\n        abstract();\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @abstract\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     */\n    Geometry.prototype.intersectsExtent = function (extent) {\n        return abstract();\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @abstract\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    Geometry.prototype.translate = function (deltaX, deltaY) {\n        abstract();\n    };\n    /**\n     * Transform each coordinate of the geometry from one coordinate reference\n     * system to another. The geometry is modified in place.\n     * For example, a line will be transformed to a line and a circle to a circle.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     *\n     * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n     * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n     * @return {Geometry} This geometry.  Note that original geometry is\n     *     modified in place.\n     * @api\n     */\n    Geometry.prototype.transform = function (source, destination) {\n        /** @type {import(\"../proj/Projection.js\").default} */\n        var sourceProj = getProjection(source);\n        var transformFn = sourceProj.getUnits() == Units.TILE_PIXELS\n            ? function (inCoordinates, outCoordinates, stride) {\n                var pixelExtent = sourceProj.getExtent();\n                var projectedExtent = sourceProj.getWorldExtent();\n                var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n                composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n                transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);\n                return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);\n            }\n            : getTransform(sourceProj, destination);\n        this.applyTransform(transformFn);\n        return this;\n    };\n    return Geometry;\n}(BaseObject));\nexport default Geometry;\n//# sourceMappingURL=Geometry.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport { abstract } from '../util.js';\nimport { createOrUpdateFromFlatCoordinates, getCenter } from '../extent.js';\nimport { rotate, scale, transform2D, translate } from './flat/transform.js';\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nvar SimpleGeometry = /** @class */ (function (_super) {\n    __extends(SimpleGeometry, _super);\n    function SimpleGeometry() {\n        var _this = _super.call(this) || this;\n        /**\n         * @protected\n         * @type {import(\"./GeometryLayout.js\").default}\n         */\n        _this.layout = GeometryLayout.XY;\n        /**\n         * @protected\n         * @type {number}\n         */\n        _this.stride = 2;\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n        _this.flatCoordinates = null;\n        return _this;\n    }\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    SimpleGeometry.prototype.computeExtent = function (extent) {\n        return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n    };\n    /**\n     * @abstract\n     * @return {Array<*>} Coordinates.\n     */\n    SimpleGeometry.prototype.getCoordinates = function () {\n        return abstract();\n    };\n    /**\n     * Return the first coordinate of the geometry.\n     * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n     * @api\n     */\n    SimpleGeometry.prototype.getFirstCoordinate = function () {\n        return this.flatCoordinates.slice(0, this.stride);\n    };\n    /**\n     * @return {Array<number>} Flat coordinates.\n     */\n    SimpleGeometry.prototype.getFlatCoordinates = function () {\n        return this.flatCoordinates;\n    };\n    /**\n     * Return the last coordinate of the geometry.\n     * @return {import(\"../coordinate.js\").Coordinate} Last point.\n     * @api\n     */\n    SimpleGeometry.prototype.getLastCoordinate = function () {\n        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n    };\n    /**\n     * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.\n     * @return {import(\"./GeometryLayout.js\").default} Layout.\n     * @api\n     */\n    SimpleGeometry.prototype.getLayout = function () {\n        return this.layout;\n    };\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {SimpleGeometry} Simplified geometry.\n     */\n    SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n        if (this.simplifiedGeometryRevision !== this.getRevision()) {\n            this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n            this.simplifiedGeometryRevision = this.getRevision();\n        }\n        // If squaredTolerance is negative or if we know that simplification will not\n        // have any effect then just return this.\n        if (squaredTolerance < 0 ||\n            (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n                squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {\n            return this;\n        }\n        var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);\n        var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n            return simplifiedGeometry;\n        }\n        else {\n            // Simplification did not actually remove any coordinates.  We now know\n            // that any calls to getSimplifiedGeometry with a squaredTolerance less\n            // than or equal to the current squaredTolerance will also not have any\n            // effect.  This allows us to short circuit simplification (saving CPU\n            // cycles) and prevents the cache of simplified geometries from filling\n            // up with useless identical copies of this geometry (saving memory).\n            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n            return this;\n        }\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {SimpleGeometry} Simplified geometry.\n     * @protected\n     */\n    SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        return this;\n    };\n    /**\n     * @return {number} Stride.\n     */\n    SimpleGeometry.prototype.getStride = function () {\n        return this.stride;\n    };\n    /**\n     * @param {import(\"./GeometryLayout.js\").default} layout Layout.\n     * @param {Array<number>} flatCoordinates Flat coordinates.\n     */\n    SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {\n        this.stride = getStrideForLayout(layout);\n        this.layout = layout;\n        this.flatCoordinates = flatCoordinates;\n    };\n    /**\n     * @abstract\n     * @param {!Array<*>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n     */\n    SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {\n        abstract();\n    };\n    /**\n     * @param {import(\"./GeometryLayout.js\").default|undefined} layout Layout.\n     * @param {Array<*>} coordinates Coordinates.\n     * @param {number} nesting Nesting.\n     * @protected\n     */\n    SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {\n        /** @type {number} */\n        var stride;\n        if (layout) {\n            stride = getStrideForLayout(layout);\n        }\n        else {\n            for (var i = 0; i < nesting; ++i) {\n                if (coordinates.length === 0) {\n                    this.layout = GeometryLayout.XY;\n                    this.stride = 2;\n                    return;\n                }\n                else {\n                    coordinates = /** @type {Array} */ (coordinates[0]);\n                }\n            }\n            stride = coordinates.length;\n            layout = getLayoutForStride(stride);\n        }\n        this.layout = layout;\n        this.stride = stride;\n    };\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     * @api\n     */\n    SimpleGeometry.prototype.applyTransform = function (transformFn) {\n        if (this.flatCoordinates) {\n            transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n            this.changed();\n        }\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in counter-clockwise radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    SimpleGeometry.prototype.rotate = function (angle, anchor) {\n        var flatCoordinates = this.getFlatCoordinates();\n        if (flatCoordinates) {\n            var stride = this.getStride();\n            rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);\n            this.changed();\n        }\n    };\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n    SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {\n        var sy = opt_sy;\n        if (sy === undefined) {\n            sy = sx;\n        }\n        var anchor = opt_anchor;\n        if (!anchor) {\n            anchor = getCenter(this.getExtent());\n        }\n        var flatCoordinates = this.getFlatCoordinates();\n        if (flatCoordinates) {\n            var stride = this.getStride();\n            scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);\n            this.changed();\n        }\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    SimpleGeometry.prototype.translate = function (deltaX, deltaY) {\n        var flatCoordinates = this.getFlatCoordinates();\n        if (flatCoordinates) {\n            var stride = this.getStride();\n            translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);\n            this.changed();\n        }\n    };\n    return SimpleGeometry;\n}(Geometry));\n/**\n * @param {number} stride Stride.\n * @return {import(\"./GeometryLayout.js\").default} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n    var layout;\n    if (stride == 2) {\n        layout = GeometryLayout.XY;\n    }\n    else if (stride == 3) {\n        layout = GeometryLayout.XYZ;\n    }\n    else if (stride == 4) {\n        layout = GeometryLayout.XYZM;\n    }\n    return /** @type {import(\"./GeometryLayout.js\").default} */ (layout);\n}\n/**\n * @param {import(\"./GeometryLayout.js\").default} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n    var stride;\n    if (layout == GeometryLayout.XY) {\n        stride = 2;\n    }\n    else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {\n        stride = 3;\n    }\n    else if (layout == GeometryLayout.XYZM) {\n        stride = 4;\n    }\n    return /** @type {number} */ (stride);\n}\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, opt_dest) {\n    var flatCoordinates = simpleGeometry.getFlatCoordinates();\n    if (!flatCoordinates) {\n        return null;\n    }\n    else {\n        var stride = simpleGeometry.getStride();\n        return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);\n    }\n}\nexport default SimpleGeometry;\n//# sourceMappingURL=SimpleGeometry.js.map","/**\n * @module ol/geom/flat/closest\n */\nimport { lerp, squaredDistance as squaredDx } from '../../math.js';\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n    var x1 = flatCoordinates[offset1];\n    var y1 = flatCoordinates[offset1 + 1];\n    var dx = flatCoordinates[offset2] - x1;\n    var dy = flatCoordinates[offset2 + 1] - y1;\n    var offset;\n    if (dx === 0 && dy === 0) {\n        offset = offset1;\n    }\n    else {\n        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            offset = offset2;\n        }\n        else if (t > 0) {\n            for (var i = 0; i < stride; ++i) {\n                closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n            }\n            closestPoint.length = stride;\n            return;\n        }\n        else {\n            offset = offset1;\n        }\n    }\n    for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n    }\n    closestPoint.length = stride;\n}\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    for (offset += stride; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        var squaredDelta = squaredDx(x1, y1, x2, y2);\n        if (squaredDelta > max) {\n            max = squaredDelta;\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n        offset = end;\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n        offset = ends[ends.length - 1];\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    if (offset == end) {\n        return minSquaredDistance;\n    }\n    var i, squaredDistance;\n    if (maxDelta === 0) {\n        // All points are identical, so just test the first point.\n        squaredDistance = squaredDx(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n        if (squaredDistance < minSquaredDistance) {\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = flatCoordinates[offset + i];\n            }\n            closestPoint.length = stride;\n            return squaredDistance;\n        }\n        else {\n            return minSquaredDistance;\n        }\n    }\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    var index = offset + stride;\n    while (index < end) {\n        assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n        squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n        if (squaredDistance < minSquaredDistance) {\n            minSquaredDistance = squaredDistance;\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = tmpPoint[i];\n            }\n            closestPoint.length = stride;\n            index += stride;\n        }\n        else {\n            // Skip ahead multiple points, because we know that all the skipped\n            // points cannot be any closer than the closest point we have found so\n            // far.  We know this because we know how close the current point is, how\n            // close the closest point we have found so far is, and the maximum\n            // distance between consecutive points.  For example, if we're currently\n            // at distance 10, the best we've found so far is 3, and that the maximum\n            // distance between consecutive points is 2, then we'll need to skip at\n            // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n            // finding a closer point.  We use Math.max(..., 1) to ensure that we\n            // always advance at least one point, to avoid an infinite loop.\n            index +=\n                stride *\n                    Math.max(((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n                        maxDelta) |\n                        0, 1);\n        }\n    }\n    if (isRing) {\n        // Check the closing segment.\n        assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n        squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n        if (squaredDistance < minSquaredDistance) {\n            minSquaredDistance = squaredDistance;\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = tmpPoint[i];\n            }\n            closestPoint.length = stride;\n        }\n    }\n    return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n        offset = end;\n    }\n    return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n        offset = ends[ends.length - 1];\n    }\n    return minSquaredDistance;\n}\n//# sourceMappingURL=closest.js.map","/**\n * @module ol/geom/flat/deflate\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n    for (var i = 0, ii = coordinate.length; i < ii; ++i) {\n        flatCoordinates[offset++] = coordinate[i];\n    }\n    return offset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {\n    for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        var coordinate = coordinates[i];\n        for (var j = 0; j < stride; ++j) {\n            flatCoordinates[offset++] = coordinate[j];\n        }\n    }\n    return offset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array<number>=} opt_ends Ends.\n * @return {Array<number>} Ends.\n */\nexport function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {\n    var ends = opt_ends ? opt_ends : [];\n    var i = 0;\n    for (var j = 0, jj = coordinatess.length; j < jj; ++j) {\n        var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);\n        ends[i++] = end;\n        offset = end;\n    }\n    ends.length = i;\n    return ends;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array<Array<number>>=} opt_endss Endss.\n * @return {Array<Array<number>>} Endss.\n */\nexport function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {\n    var endss = opt_endss ? opt_endss : [];\n    var i = 0;\n    for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {\n        var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);\n        endss[i++] = ends;\n        offset = ends[ends.length - 1];\n    }\n    endss.length = i;\n    return endss;\n}\n//# sourceMappingURL=deflate.js.map","/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\nimport { squaredDistance, squaredSegmentDistance } from '../../math.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n    var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined\n        ? opt_simplifiedFlatCoordinates\n        : [];\n    if (!highQuality) {\n        end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        flatCoordinates = simplifiedFlatCoordinates;\n        offset = 0;\n        stride = 2;\n    }\n    simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    return simplifiedFlatCoordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    var n = (end - offset) / stride;\n    if (n < 3) {\n        for (; offset < end; offset += stride) {\n            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + 1];\n        }\n        return simplifiedOffset;\n    }\n    /** @type {Array<number>} */\n    var markers = new Array(n);\n    markers[0] = 1;\n    markers[n - 1] = 1;\n    /** @type {Array<number>} */\n    var stack = [offset, end - stride];\n    var index = 0;\n    while (stack.length > 0) {\n        var last = stack.pop();\n        var first = stack.pop();\n        var maxSquaredDistance = 0;\n        var x1 = flatCoordinates[first];\n        var y1 = flatCoordinates[first + 1];\n        var x2 = flatCoordinates[last];\n        var y2 = flatCoordinates[last + 1];\n        for (var i = first + stride; i < last; i += stride) {\n            var x = flatCoordinates[i];\n            var y = flatCoordinates[i + 1];\n            var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n            if (squaredDistance_1 > maxSquaredDistance) {\n                index = i;\n                maxSquaredDistance = squaredDistance_1;\n            }\n        }\n        if (maxSquaredDistance > squaredTolerance) {\n            markers[(index - offset) / stride] = 1;\n            if (first + stride < index) {\n                stack.push(first, index);\n            }\n            if (index + stride < last) {\n                stack.push(index, last);\n            }\n        }\n    }\n    for (var i = 0; i < n; ++i) {\n        if (markers[i]) {\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + i * stride];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + i * stride + 1];\n        }\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n        simplifiedEnds.push(simplifiedOffset);\n        offset = end;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        var simplifiedEnds = [];\n        simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n        simplifiedEndss.push(simplifiedEnds);\n        offset = ends[ends.length - 1];\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    if (end <= offset + stride) {\n        // zero or one point, no simplification possible, so copy and return\n        for (; offset < end; offset += stride) {\n            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n            simplifiedFlatCoordinates[simplifiedOffset++] =\n                flatCoordinates[offset + 1];\n        }\n        return simplifiedOffset;\n    }\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    // copy first point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n    var x2 = x1;\n    var y2 = y1;\n    for (offset += stride; offset < end; offset += stride) {\n        x2 = flatCoordinates[offset];\n        y2 = flatCoordinates[offset + 1];\n        if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n            // copy point at offset\n            simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n            simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n    if (x2 != x1 || y2 != y1) {\n        // copy last point\n        simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n        simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n    return tolerance * Math.round(value / tolerance);\n}\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n    // do nothing if the line is empty\n    if (offset == end) {\n        return simplifiedOffset;\n    }\n    // snap the first coordinate (P1)\n    var x1 = snap(flatCoordinates[offset], tolerance);\n    var y1 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // add the first coordinate to the output\n    simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n    // find the next coordinate that does not snap to the same value as the first\n    // coordinate (P2)\n    var x2, y2;\n    do {\n        x2 = snap(flatCoordinates[offset], tolerance);\n        y2 = snap(flatCoordinates[offset + 1], tolerance);\n        offset += stride;\n        if (offset == end) {\n            // all coordinates snap to the same value, the line collapses to a point\n            // push the last snapped value anyway to ensure that the output contains\n            // at least two points\n            // FIXME should we really return at least two points anyway?\n            simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n            simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n            return simplifiedOffset;\n        }\n    } while (x2 == x1 && y2 == y1);\n    while (offset < end) {\n        // snap the next coordinate (P3)\n        var x3 = snap(flatCoordinates[offset], tolerance);\n        var y3 = snap(flatCoordinates[offset + 1], tolerance);\n        offset += stride;\n        // skip P3 if it is equal to P2\n        if (x3 == x2 && y3 == y2) {\n            continue;\n        }\n        // calculate the delta between P1 and P2\n        var dx1 = x2 - x1;\n        var dy1 = y2 - y1;\n        // calculate the delta between P3 and P1\n        var dx2 = x3 - x1;\n        var dy2 = y3 - y1;\n        // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n        // P1 in the same direction then P2 is on the straight line between P1 and\n        // P3\n        if (dx1 * dy2 == dy1 * dx2 &&\n            ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n            ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\n            // discard P2 and set P2 = P3\n            x2 = x3;\n            y2 = y3;\n            continue;\n        }\n        // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n        // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n        // and continue with P1 = P2 and P2 = P3\n        simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n        simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n        x1 = x2;\n        y1 = y2;\n        x2 = x3;\n        y2 = y3;\n    }\n    // add the last point (P2)\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n        simplifiedEnds.push(simplifiedOffset);\n        offset = end;\n    }\n    return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        var simplifiedEnds = [];\n        simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n        simplifiedEndss.push(simplifiedEnds);\n        offset = ends[ends.length - 1];\n    }\n    return simplifiedOffset;\n}\n//# sourceMappingURL=simplify.js.map","/**\n * @module ol/geom/flat/inflate\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>=} opt_coordinates Coordinates.\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n */\nexport function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {\n    var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];\n    var i = 0;\n    for (var j = offset; j < end; j += stride) {\n        coordinates[i++] = flatCoordinates.slice(j, j + stride);\n    }\n    coordinates.length = i;\n    return coordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>=} opt_coordinatess Coordinatess.\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n */\nexport function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {\n    var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];\n    var i = 0;\n    for (var j = 0, jj = ends.length; j < jj; ++j) {\n        var end = ends[j];\n        coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);\n        offset = end;\n    }\n    coordinatess.length = i;\n    return coordinatess;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>=} opt_coordinatesss\n *     Coordinatesss.\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n */\nexport function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {\n    var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];\n    var i = 0;\n    for (var j = 0, jj = endss.length; j < jj; ++j) {\n        var ends = endss[j];\n        coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);\n        offset = ends[ends.length - 1];\n    }\n    coordinatesss.length = i;\n    return coordinatesss;\n}\n//# sourceMappingURL=inflate.js.map","/**\n * @module ol/geom/flat/area\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRing(flatCoordinates, offset, end, stride) {\n    var twiceArea = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        twiceArea += y1 * x2 - x1 * y2;\n        x1 = x2;\n        y1 = y2;\n    }\n    return twiceArea / 2;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRings(flatCoordinates, offset, ends, stride) {\n    var area = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        area += linearRing(flatCoordinates, offset, end, stride);\n        offset = end;\n    }\n    return area;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n    var area = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        area += linearRings(flatCoordinates, offset, ends, stride);\n        offset = ends[ends.length - 1];\n    }\n    return area;\n}\n//# sourceMappingURL=area.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/LinearRing\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { assignClosestPoint, maxSquaredDelta } from './flat/closest.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport { deflateCoordinates } from './flat/deflate.js';\nimport { douglasPeucker } from './flat/simplify.js';\nimport { inflateCoordinates } from './flat/inflate.js';\nimport { linearRing as linearRingArea } from './flat/area.js';\n/**\n * @classdesc\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\n * on its own.\n *\n * @api\n */\nvar LinearRing = /** @class */ (function (_super) {\n    __extends(LinearRing, _super);\n    /**\n     * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.\n     * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n     */\n    function LinearRing(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!LinearRing} Clone.\n     * @api\n     */\n    LinearRing.prototype.clone = function () {\n        return new LinearRing(this.flatCoordinates.slice(), this.layout);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    LinearRing.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * Return the area of the linear ring on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    LinearRing.prototype.getArea = function () {\n        return linearRingArea(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * Return the coordinates of the linear ring.\n     * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n     * @api\n     */\n    LinearRing.prototype.getCoordinates = function () {\n        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LinearRing} Simplified LinearRing.\n     * @protected\n     */\n    LinearRing.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n        return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    LinearRing.prototype.getType = function () {\n        return GeometryType.LINEAR_RING;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    LinearRing.prototype.intersectsExtent = function (extent) {\n        return false;\n    };\n    /**\n     * Set the coordinates of the linear ring.\n     * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n     * @api\n     */\n    LinearRing.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 1);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return LinearRing;\n}(SimpleGeometry));\nexport default LinearRing;\n//# sourceMappingURL=LinearRing.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Point\n */\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { containsXY, createOrUpdateFromCoordinate } from '../extent.js';\nimport { deflateCoordinate } from './flat/deflate.js';\nimport { squaredDistance as squaredDx } from '../math.js';\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\nvar Point = /** @class */ (function (_super) {\n    __extends(Point, _super);\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n     */\n    function Point(coordinates, opt_layout) {\n        var _this = _super.call(this) || this;\n        _this.setCoordinates(coordinates, opt_layout);\n        return _this;\n    }\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Point} Clone.\n     * @api\n     */\n    Point.prototype.clone = function () {\n        var point = new Point(this.flatCoordinates.slice(), this.layout);\n        point.applyProperties(this);\n        return point;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        var flatCoordinates = this.flatCoordinates;\n        var squaredDistance = squaredDx(x, y, flatCoordinates[0], flatCoordinates[1]);\n        if (squaredDistance < minSquaredDistance) {\n            var stride = this.stride;\n            for (var i = 0; i < stride; ++i) {\n                closestPoint[i] = flatCoordinates[i];\n            }\n            closestPoint.length = stride;\n            return squaredDistance;\n        }\n        else {\n            return minSquaredDistance;\n        }\n    };\n    /**\n     * Return the coordinate of the point.\n     * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n     * @api\n     */\n    Point.prototype.getCoordinates = function () {\n        return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    Point.prototype.computeExtent = function (extent) {\n        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    Point.prototype.getType = function () {\n        return GeometryType.POINT;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Point.prototype.intersectsExtent = function (extent) {\n        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n    };\n    /**\n     * @param {!Array<*>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n     * @api\n     */\n    Point.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 0);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);\n        this.changed();\n    };\n    return Point;\n}(SimpleGeometry));\nexport default Point;\n//# sourceMappingURL=Point.js.map","/**\n * @module ol/geom/flat/contains\n */\nimport { forEachCorner } from '../../extent.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {\n    var outside = forEachCorner(extent, \n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n        return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);\n    });\n    return !outside;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {\n    // http://geomalgorithms.com/a03-_inclusion.html\n    // Copyright 2000 softSurfer, 2012 Dan Sunday\n    // This code may be freely used and modified for any purpose\n    // providing that this copyright notice is included with it.\n    // SoftSurfer makes no warranty for this code, and cannot be held\n    // liable for any real or imagined damage resulting from its use.\n    // Users of this code must verify correctness for their application.\n    var wn = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        if (y1 <= y) {\n            if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n                wn++;\n            }\n        }\n        else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n            wn--;\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    return wn !== 0;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {\n    if (ends.length === 0) {\n        return false;\n    }\n    if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n        return false;\n    }\n    for (var i = 1, ii = ends.length; i < ii; ++i) {\n        if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {\n    if (endss.length === 0) {\n        return false;\n    }\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n            return true;\n        }\n        offset = ends[ends.length - 1];\n    }\n    return false;\n}\n//# sourceMappingURL=contains.js.map","/**\n * @module ol/geom/flat/interiorpoint\n */\nimport { linearRingsContainsXY } from './contains.js';\nimport { numberSafeCompareFunction } from '../../array.js';\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {\n    var i, ii, x, x1, x2, y1, y2;\n    var y = flatCenters[flatCentersOffset + 1];\n    /** @type {Array<number>} */\n    var intersections = [];\n    // Calculate intersections with the horizontal line\n    for (var r = 0, rr = ends.length; r < rr; ++r) {\n        var end = ends[r];\n        x1 = flatCoordinates[end - stride];\n        y1 = flatCoordinates[end - stride + 1];\n        for (i = offset; i < end; i += stride) {\n            x2 = flatCoordinates[i];\n            y2 = flatCoordinates[i + 1];\n            if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n                x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\n                intersections.push(x);\n            }\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n    // Find the longest segment of the horizontal line that has its center point\n    // inside the linear ring.\n    var pointX = NaN;\n    var maxSegmentLength = -Infinity;\n    intersections.sort(numberSafeCompareFunction);\n    x1 = intersections[0];\n    for (i = 1, ii = intersections.length; i < ii; ++i) {\n        x2 = intersections[i];\n        var segmentLength = Math.abs(x2 - x1);\n        if (segmentLength > maxSegmentLength) {\n            x = (x1 + x2) / 2;\n            if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n                pointX = x;\n                maxSegmentLength = segmentLength;\n            }\n        }\n        x1 = x2;\n    }\n    if (isNaN(pointX)) {\n        // There is no horizontal line that has its center point inside the linear\n        // ring.  Use the center of the the linear ring's extent.\n        pointX = flatCenters[flatCentersOffset];\n    }\n    if (opt_dest) {\n        opt_dest.push(pointX, y, maxSegmentLength);\n        return opt_dest;\n    }\n    else {\n        return [pointX, y, maxSegmentLength];\n    }\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {\n    var interiorPoints = [];\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);\n        offset = ends[ends.length - 1];\n    }\n    return interiorPoints;\n}\n//# sourceMappingURL=interiorpoint.js.map","/**\n * @module ol/geom/flat/segments\n */\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n    var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n    var point2 = [];\n    var ret;\n    for (; offset + stride < end; offset += stride) {\n        point2[0] = flatCoordinates[offset + stride];\n        point2[1] = flatCoordinates[offset + stride + 1];\n        ret = callback(point1, point2);\n        if (ret) {\n            return ret;\n        }\n        point1[0] = point2[0];\n        point1[1] = point2[1];\n    }\n    return false;\n}\n//# sourceMappingURL=segments.js.map","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport { containsExtent, createEmpty, extendFlatCoordinates, intersects, intersectsSegment, } from '../../extent.js';\nimport { forEach as forEachSegment } from './segments.js';\nimport { linearRingContainsExtent, linearRingContainsXY } from './contains.js';\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(flatCoordinates, offset, end, stride, extent) {\n    var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);\n    if (!intersects(extent, coordinatesExtent)) {\n        return false;\n    }\n    if (containsExtent(extent, coordinatesExtent)) {\n        return true;\n    }\n    if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n        return true;\n    }\n    if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n        return true;\n    }\n    return forEachSegment(flatCoordinates, offset, end, stride, \n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n        return intersectsSegment(extent, point1, point2);\n    });\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {\n            return true;\n        }\n        offset = ends[i];\n    }\n    return false;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {\n    if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {\n        return true;\n    }\n    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {\n        return true;\n    }\n    return false;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {\n    if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n        return false;\n    }\n    if (ends.length === 1) {\n        return true;\n    }\n    for (var i = 1, ii = ends.length; i < ii; ++i) {\n        if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n            if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {\n            return true;\n        }\n        offset = ends[ends.length - 1];\n    }\n    return false;\n}\n//# sourceMappingURL=intersectsextent.js.map","/**\n * @module ol/geom/flat/reverse\n */\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n */\nexport function coordinates(flatCoordinates, offset, end, stride) {\n    while (offset < end - stride) {\n        for (var i = 0; i < stride; ++i) {\n            var tmp = flatCoordinates[offset + i];\n            flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n            flatCoordinates[end - stride + i] = tmp;\n        }\n        offset += stride;\n        end -= stride;\n    }\n}\n//# sourceMappingURL=reverse.js.map","/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from './reverse.js';\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n    // http://tinyurl.com/clockwise-method\n    // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp\n    var edge = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        edge += (x2 - x1) * (y2 + y1);\n        x1 = x2;\n        y1 = y2;\n    }\n    return edge === 0 ? undefined : edge > 0;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        if (i === 0) {\n            if ((right && isClockwise) || (!right && !isClockwise)) {\n                return false;\n            }\n        }\n        else {\n            if ((right && !isClockwise) || (!right && isClockwise)) {\n                return false;\n            }\n        }\n        offset = end;\n    }\n    return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {\n            return false;\n        }\n        if (ends.length) {\n            offset = ends[ends.length - 1];\n        }\n    }\n    return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        var reverse = i === 0\n            ? (right && isClockwise) || (!right && !isClockwise)\n            : (right && !isClockwise) || (!right && isClockwise);\n        if (reverse) {\n            reverseCoordinates(flatCoordinates, offset, end, stride);\n        }\n        offset = end;\n    }\n    return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n    }\n    return offset;\n}\n//# sourceMappingURL=orient.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/Polygon\n */\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { arrayMaxSquaredDelta, assignClosestArrayPoint } from './flat/closest.js';\nimport { closestSquaredDistanceXY, getCenter } from '../extent.js';\nimport { deflateCoordinatesArray } from './flat/deflate.js';\nimport { extend } from '../array.js';\nimport { getInteriorPointOfArray } from './flat/interiorpoint.js';\nimport { inflateCoordinatesArray } from './flat/inflate.js';\nimport { intersectsLinearRingArray } from './flat/intersectsextent.js';\nimport { linearRingsAreOriented, orientLinearRings } from './flat/orient.js';\nimport { linearRings as linearRingsArea } from './flat/area.js';\nimport { linearRingsContainsXY } from './flat/contains.js';\nimport { modulo } from '../math.js';\nimport { quantizeArray } from './flat/simplify.js';\nimport { offset as sphereOffset } from '../sphere.js';\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nvar Polygon = /** @class */ (function (_super) {\n    __extends(Polygon, _super);\n    /**\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n     *     Array of linear rings that define the polygon. The first linear ring of the\n     *     array defines the outer-boundary or surface of the polygon. Each subsequent\n     *     linear ring defines a hole in the surface of the polygon. A linear ring is\n     *     an array of vertices' coordinates where the first coordinate and the last are\n     *     equivalent. (For internal use, flat coordinates in combination with\n     *     `opt_layout` and `opt_ends` are also accepted.)\n     * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n     * @param {Array<number>=} opt_ends Ends (for internal use with flat coordinates).\n     */\n    function Polygon(coordinates, opt_layout, opt_ends) {\n        var _this = _super.call(this) || this;\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.ends_ = [];\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.flatInteriorPointRevision_ = -1;\n        /**\n         * @private\n         * @type {import(\"../coordinate.js\").Coordinate}\n         */\n        _this.flatInteriorPoint_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDelta_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.maxDeltaRevision_ = -1;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.orientedRevision_ = -1;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.orientedFlatCoordinates_ = null;\n        if (opt_layout !== undefined && opt_ends) {\n            _this.setFlatCoordinates(opt_layout, \n            /** @type {Array<number>} */ (coordinates));\n            _this.ends_ = opt_ends;\n        }\n        else {\n            _this.setCoordinates(\n            /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n        }\n        return _this;\n    }\n    /**\n     * Append the passed linear ring to this polygon.\n     * @param {LinearRing} linearRing Linear ring.\n     * @api\n     */\n    Polygon.prototype.appendLinearRing = function (linearRing) {\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n        }\n        else {\n            extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n        }\n        this.ends_.push(this.flatCoordinates.length);\n        this.changed();\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!Polygon} Clone.\n     * @api\n     */\n    Polygon.prototype.clone = function () {\n        var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n        polygon.applyProperties(this);\n        return polygon;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        if (this.maxDeltaRevision_ != this.getRevision()) {\n            this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n            this.maxDeltaRevision_ = this.getRevision();\n        }\n        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    Polygon.prototype.containsXY = function (x, y) {\n        return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n    };\n    /**\n     * Return the area of the polygon on projected plane.\n     * @return {number} Area (on projected plane).\n     * @api\n     */\n    Polygon.prototype.getArea = function () {\n        return linearRingsArea(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n    };\n    /**\n     * Get the coordinate array for this geometry.  This array has the structure\n     * of a GeoJSON coordinate array for polygons.\n     *\n     * @param {boolean=} opt_right Orient coordinates according to the right-hand\n     *     rule (counter-clockwise for exterior and clockwise for interior rings).\n     *     If `false`, coordinates will be oriented according to the left-hand rule\n     *     (clockwise for exterior and counter-clockwise for interior rings).\n     *     By default, coordinate orientation will depend on how the geometry was\n     *     constructed.\n     * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n     * @api\n     */\n    Polygon.prototype.getCoordinates = function (opt_right) {\n        var flatCoordinates;\n        if (opt_right !== undefined) {\n            flatCoordinates = this.getOrientedFlatCoordinates().slice();\n            orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n        }\n        else {\n            flatCoordinates = this.flatCoordinates;\n        }\n        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n    };\n    /**\n     * @return {Array<number>} Ends.\n     */\n    Polygon.prototype.getEnds = function () {\n        return this.ends_;\n    };\n    /**\n     * @return {Array<number>} Interior point.\n     */\n    Polygon.prototype.getFlatInteriorPoint = function () {\n        if (this.flatInteriorPointRevision_ != this.getRevision()) {\n            var flatCenter = getCenter(this.getExtent());\n            this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n            this.flatInteriorPointRevision_ = this.getRevision();\n        }\n        return this.flatInteriorPoint_;\n    };\n    /**\n     * Return an interior point of the polygon.\n     * @return {Point} Interior point as XYM coordinate, where M is the\n     * length of the horizontal intersection that the point belongs to.\n     * @api\n     */\n    Polygon.prototype.getInteriorPoint = function () {\n        return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n    };\n    /**\n     * Return the number of rings of the polygon,  this includes the exterior\n     * ring and any interior rings.\n     *\n     * @return {number} Number of rings.\n     * @api\n     */\n    Polygon.prototype.getLinearRingCount = function () {\n        return this.ends_.length;\n    };\n    /**\n     * Return the Nth linear ring of the polygon geometry. Return `null` if the\n     * given index is out of range.\n     * The exterior linear ring is available at index `0` and the interior rings\n     * at index `1` and beyond.\n     *\n     * @param {number} index Index.\n     * @return {LinearRing} Linear ring.\n     * @api\n     */\n    Polygon.prototype.getLinearRing = function (index) {\n        if (index < 0 || this.ends_.length <= index) {\n            return null;\n        }\n        return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n    };\n    /**\n     * Return the linear rings of the polygon.\n     * @return {Array<LinearRing>} Linear rings.\n     * @api\n     */\n    Polygon.prototype.getLinearRings = function () {\n        var layout = this.layout;\n        var flatCoordinates = this.flatCoordinates;\n        var ends = this.ends_;\n        var linearRings = [];\n        var offset = 0;\n        for (var i = 0, ii = ends.length; i < ii; ++i) {\n            var end = ends[i];\n            var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);\n            linearRings.push(linearRing);\n            offset = end;\n        }\n        return linearRings;\n    };\n    /**\n     * @return {Array<number>} Oriented flat coordinates.\n     */\n    Polygon.prototype.getOrientedFlatCoordinates = function () {\n        if (this.orientedRevision_ != this.getRevision()) {\n            var flatCoordinates = this.flatCoordinates;\n            if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n                this.orientedFlatCoordinates_ = flatCoordinates;\n            }\n            else {\n                this.orientedFlatCoordinates_ = flatCoordinates.slice();\n                this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n            }\n            this.orientedRevision_ = this.getRevision();\n        }\n        return this.orientedFlatCoordinates_;\n    };\n    /**\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {Polygon} Simplified Polygon.\n     * @protected\n     */\n    Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedEnds = [];\n        simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n        return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    Polygon.prototype.getType = function () {\n        return GeometryType.POLYGON;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    Polygon.prototype.intersectsExtent = function (extent) {\n        return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n    };\n    /**\n     * Set the coordinates of the polygon.\n     * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n     * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n     * @api\n     */\n    Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {\n        this.setLayout(opt_layout, coordinates, 2);\n        if (!this.flatCoordinates) {\n            this.flatCoordinates = [];\n        }\n        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n        this.changed();\n    };\n    return Polygon;\n}(SimpleGeometry));\nexport default Polygon;\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices.\n * @param {number=} opt_n Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number=} opt_sphereRadius Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\n    var n = opt_n ? opt_n : 32;\n    /** @type {Array<number>} */\n    var flatCoordinates = [];\n    for (var i = 0; i < n; ++i) {\n        extend(flatCoordinates, sphereOffset(center, radius, (2 * Math.PI * i) / n, opt_sphereRadius));\n    }\n    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n    return new Polygon(flatCoordinates, GeometryLayout.XY, [\n        flatCoordinates.length,\n    ]);\n}\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var flatCoordinates = [\n        minX,\n        minY,\n        minX,\n        maxY,\n        maxX,\n        maxY,\n        maxX,\n        minY,\n        minX,\n        minY,\n    ];\n    return new Polygon(flatCoordinates, GeometryLayout.XY, [\n        flatCoordinates.length,\n    ]);\n}\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number=} opt_sides Number of sides of the polygon. Default is 32.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, opt_sides, opt_angle) {\n    var sides = opt_sides ? opt_sides : 32;\n    var stride = circle.getStride();\n    var layout = circle.getLayout();\n    var center = circle.getCenter();\n    var arrayLength = stride * (sides + 1);\n    var flatCoordinates = new Array(arrayLength);\n    for (var i = 0; i < arrayLength; i += stride) {\n        flatCoordinates[i] = 0;\n        flatCoordinates[i + 1] = 0;\n        for (var j = 2; j < stride; j++) {\n            flatCoordinates[i + j] = center[j];\n        }\n    }\n    var ends = [flatCoordinates.length];\n    var polygon = new Polygon(flatCoordinates, layout, ends);\n    makeRegular(polygon, center, circle.getRadius(), opt_angle);\n    return polygon;\n}\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, opt_angle) {\n    var flatCoordinates = polygon.getFlatCoordinates();\n    var stride = polygon.getStride();\n    var sides = flatCoordinates.length / stride - 1;\n    var startAngle = opt_angle ? opt_angle : 0;\n    for (var i = 0; i <= sides; ++i) {\n        var offset = i * stride;\n        var angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\n        flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n        flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n    }\n    polygon.changed();\n}\n//# sourceMappingURL=Polygon.js.map","/**\n * @module ol/color\n */\nimport { assert } from './asserts.js';\nimport { clamp } from './math.js';\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n/**\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\nvar HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\nvar NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\\(.*\\)$/i;\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n    if (typeof color === 'string') {\n        return color;\n    }\n    else {\n        return toString(color);\n    }\n}\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\nfunction fromNamed(color) {\n    var el = document.createElement('div');\n    el.style.color = color;\n    if (el.style.color !== '') {\n        document.body.appendChild(el);\n        var rgb = getComputedStyle(el).color;\n        document.body.removeChild(el);\n        return rgb;\n    }\n    else {\n        return '';\n    }\n}\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport var fromString = (function () {\n    // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n    // semantics, whenever the cache grows too large we simply delete an\n    // arbitrary 25% of the entries.\n    /**\n     * @const\n     * @type {number}\n     */\n    var MAX_CACHE_SIZE = 1024;\n    /**\n     * @type {Object<string, Color>}\n     */\n    var cache = {};\n    /**\n     * @type {number}\n     */\n    var cacheSize = 0;\n    return (\n    /**\n     * @param {string} s String.\n     * @return {Color} Color.\n     */\n    function (s) {\n        var color;\n        if (cache.hasOwnProperty(s)) {\n            color = cache[s];\n        }\n        else {\n            if (cacheSize >= MAX_CACHE_SIZE) {\n                var i = 0;\n                for (var key in cache) {\n                    if ((i++ & 3) === 0) {\n                        delete cache[key];\n                        --cacheSize;\n                    }\n                }\n            }\n            color = fromStringInternal_(s);\n            cache[s] = color;\n            ++cacheSize;\n        }\n        return color;\n    });\n})();\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n    if (Array.isArray(color)) {\n        return color;\n    }\n    else {\n        return fromString(color);\n    }\n}\n/**\n * @param {string} s String.\n * @private\n * @return {Color} Color.\n */\nfunction fromStringInternal_(s) {\n    var r, g, b, a, color;\n    if (NAMED_COLOR_RE_.exec(s)) {\n        s = fromNamed(s);\n    }\n    if (HEX_COLOR_RE_.exec(s)) {\n        // hex\n        var n = s.length - 1; // number of hex digits\n        var d = // number of digits per channel\n         void 0; // number of digits per channel\n        if (n <= 4) {\n            d = 1;\n        }\n        else {\n            d = 2;\n        }\n        var hasAlpha = n === 4 || n === 8;\n        r = parseInt(s.substr(1 + 0 * d, d), 16);\n        g = parseInt(s.substr(1 + 1 * d, d), 16);\n        b = parseInt(s.substr(1 + 2 * d, d), 16);\n        if (hasAlpha) {\n            a = parseInt(s.substr(1 + 3 * d, d), 16);\n        }\n        else {\n            a = 255;\n        }\n        if (d == 1) {\n            r = (r << 4) + r;\n            g = (g << 4) + g;\n            b = (b << 4) + b;\n            if (hasAlpha) {\n                a = (a << 4) + a;\n            }\n        }\n        color = [r, g, b, a / 255];\n    }\n    else if (s.indexOf('rgba(') == 0) {\n        // rgba()\n        color = s.slice(5, -1).split(',').map(Number);\n        normalize(color);\n    }\n    else if (s.indexOf('rgb(') == 0) {\n        // rgb()\n        color = s.slice(4, -1).split(',').map(Number);\n        color.push(1);\n        normalize(color);\n    }\n    else {\n        assert(false, 14); // Invalid color\n    }\n    return color;\n}\n/**\n * TODO this function is only used in the test, we probably shouldn't export it\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n    color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\n    color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\n    color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\n    color[3] = clamp(color[3], 0, 1);\n    return color;\n}\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n    var r = color[0];\n    if (r != (r | 0)) {\n        r = (r + 0.5) | 0;\n    }\n    var g = color[1];\n    if (g != (g | 0)) {\n        g = (g + 0.5) | 0;\n    }\n    var b = color[2];\n    if (b != (b | 0)) {\n        b = (b + 0.5) | 0;\n    }\n    var a = color[3] === undefined ? 1 : color[3];\n    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n    if (NAMED_COLOR_RE_.test(s)) {\n        s = fromNamed(s);\n    }\n    return (HEX_COLOR_RE_.test(s) || s.indexOf('rgba(') === 0 || s.indexOf('rgb(') === 0);\n}\n//# sourceMappingURL=color.js.map","/**\n * @module ol/centerconstraint\n */\nimport { clamp } from './math.js';\n/**\n * @typedef {function((import(\"./coordinate.js\").Coordinate|undefined), number, import(\"./size.js\").Size, boolean=, Array<number>=): (import(\"./coordinate.js\").Coordinate|undefined)} Type\n */\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.\n * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent\n * (only during interaction and animation).\n * @return {Type} The constraint.\n */\nexport function createExtent(extent, onlyCenter, smooth) {\n    return (\n    /**\n     * @param {import(\"./coordinate.js\").Coordinate|undefined} center Center.\n     * @param {number} resolution Resolution.\n     * @param {import(\"./size.js\").Size} size Viewport size; unused if `onlyCenter` was specified.\n     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.\n     * @param {Array<number>=} opt_centerShift Shift between map center and viewport center.\n     * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n     */\n    function (center, resolution, size, opt_isMoving, opt_centerShift) {\n        if (center) {\n            var viewWidth = onlyCenter ? 0 : size[0] * resolution;\n            var viewHeight = onlyCenter ? 0 : size[1] * resolution;\n            var shiftX = opt_centerShift ? opt_centerShift[0] : 0;\n            var shiftY = opt_centerShift ? opt_centerShift[1] : 0;\n            var minX = extent[0] + viewWidth / 2 + shiftX;\n            var maxX = extent[2] - viewWidth / 2 + shiftX;\n            var minY = extent[1] + viewHeight / 2 + shiftY;\n            var maxY = extent[3] - viewHeight / 2 + shiftY;\n            // note: when zooming out of bounds, min and max values for x and y may\n            // end up inverted (min > max); this has to be accounted for\n            if (minX > maxX) {\n                minX = (maxX + minX) / 2;\n                maxX = minX;\n            }\n            if (minY > maxY) {\n                minY = (maxY + minY) / 2;\n                maxY = minY;\n            }\n            var x = clamp(center[0], minX, maxX);\n            var y = clamp(center[1], minY, maxY);\n            var ratio = 30 * resolution;\n            // during an interaction, allow some overscroll\n            if (opt_isMoving && smooth) {\n                x +=\n                    -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +\n                        ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);\n                y +=\n                    -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +\n                        ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);\n            }\n            return [x, y];\n        }\n        else {\n            return undefined;\n        }\n    });\n}\n/**\n * @param {import(\"./coordinate.js\").Coordinate=} center Center.\n * @return {import(\"./coordinate.js\").Coordinate|undefined} Center.\n */\nexport function none(center) {\n    return center;\n}\n//# sourceMappingURL=centerconstraint.js.map","/**\n * @module ol/asserts\n */\nimport AssertionError from './AssertionError.js';\n/**\n * @param {*} assertion Assertion we expected to be truthy.\n * @param {number} errorCode Error code.\n */\nexport function assert(assertion, errorCode) {\n    if (!assertion) {\n        throw new AssertionError(errorCode);\n    }\n}\n//# sourceMappingURL=asserts.js.map","/**\n * @module ol/array\n */\n/**\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\n * https://github.com/darkskyapp/binary-search\n *\n * @param {Array<*>} haystack Items to search through.\n * @param {*} needle The item to look for.\n * @param {Function=} opt_comparator Comparator function.\n * @return {number} The index of the item if found, -1 if not.\n */\nexport function binarySearch(haystack, needle, opt_comparator) {\n    var mid, cmp;\n    var comparator = opt_comparator || numberSafeCompareFunction;\n    var low = 0;\n    var high = haystack.length;\n    var found = false;\n    while (low < high) {\n        /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\n         * to double (which gives the wrong results). */\n        mid = low + ((high - low) >> 1);\n        cmp = +comparator(haystack[mid], needle);\n        if (cmp < 0.0) {\n            /* Too low. */\n            low = mid + 1;\n        }\n        else {\n            /* Key found or too high */\n            high = mid;\n            found = !cmp;\n        }\n    }\n    /* Key not found. */\n    return found ? low : ~low;\n}\n/**\n * Compare function for array sort that is safe for numbers.\n * @param {*} a The first object to be compared.\n * @param {*} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second.\n */\nexport function numberSafeCompareFunction(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n}\n/**\n * Whether the array contains the given object.\n * @param {Array<*>} arr The array to test for the presence of the element.\n * @param {*} obj The object for which to test.\n * @return {boolean} The object is in the array.\n */\nexport function includes(arr, obj) {\n    return arr.indexOf(obj) >= 0;\n}\n/**\n * @param {Array<number>} arr Array.\n * @param {number} target Target.\n * @param {number} direction 0 means return the nearest, > 0\n *    means return the largest nearest, < 0 means return the\n *    smallest nearest.\n * @return {number} Index.\n */\nexport function linearFindNearest(arr, target, direction) {\n    var n = arr.length;\n    if (arr[0] <= target) {\n        return 0;\n    }\n    else if (target <= arr[n - 1]) {\n        return n - 1;\n    }\n    else {\n        var i = void 0;\n        if (direction > 0) {\n            for (i = 1; i < n; ++i) {\n                if (arr[i] < target) {\n                    return i - 1;\n                }\n            }\n        }\n        else if (direction < 0) {\n            for (i = 1; i < n; ++i) {\n                if (arr[i] <= target) {\n                    return i;\n                }\n            }\n        }\n        else {\n            for (i = 1; i < n; ++i) {\n                if (arr[i] == target) {\n                    return i;\n                }\n                else if (arr[i] < target) {\n                    if (arr[i - 1] - target < target - arr[i]) {\n                        return i - 1;\n                    }\n                    else {\n                        return i;\n                    }\n                }\n            }\n        }\n        return n - 1;\n    }\n}\n/**\n * @param {Array<*>} arr Array.\n * @param {number} begin Begin index.\n * @param {number} end End index.\n */\nexport function reverseSubArray(arr, begin, end) {\n    while (begin < end) {\n        var tmp = arr[begin];\n        arr[begin] = arr[end];\n        arr[end] = tmp;\n        ++begin;\n        --end;\n    }\n}\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\n * @template VALUE\n */\nexport function extend(arr, data) {\n    var extension = Array.isArray(data) ? data : [data];\n    var length = extension.length;\n    for (var i = 0; i < length; i++) {\n        arr[arr.length] = extension[i];\n    }\n}\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {VALUE} obj The element to remove.\n * @template VALUE\n * @return {boolean} If the element was removed.\n */\nexport function remove(arr, obj) {\n    var i = arr.indexOf(obj);\n    var found = i > -1;\n    if (found) {\n        arr.splice(i, 1);\n    }\n    return found;\n}\n/**\n * @param {Array<VALUE>} arr The array to search in.\n * @param {function(VALUE, number, ?) : boolean} func The function to compare.\n * @template VALUE\n * @return {VALUE|null} The element found or null.\n */\nexport function find(arr, func) {\n    var length = arr.length >>> 0;\n    var value;\n    for (var i = 0; i < length; i++) {\n        value = arr[i];\n        if (func(value, i, arr)) {\n            return value;\n        }\n    }\n    return null;\n}\n/**\n * @param {Array|Uint8ClampedArray} arr1 The first array to compare.\n * @param {Array|Uint8ClampedArray} arr2 The second array to compare.\n * @return {boolean} Whether the two arrays are equal.\n */\nexport function equals(arr1, arr2) {\n    var len1 = arr1.length;\n    if (len1 !== arr2.length) {\n        return false;\n    }\n    for (var i = 0; i < len1; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Sort the passed array such that the relative order of equal elements is preverved.\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\n * @param {Array<*>} arr The array to sort (modifies original).\n * @param {!function(*, *): number} compareFnc Comparison function.\n * @api\n */\nexport function stableSort(arr, compareFnc) {\n    var length = arr.length;\n    var tmp = Array(arr.length);\n    var i;\n    for (i = 0; i < length; i++) {\n        tmp[i] = { index: i, value: arr[i] };\n    }\n    tmp.sort(function (a, b) {\n        return compareFnc(a.value, b.value) || a.index - b.index;\n    });\n    for (i = 0; i < arr.length; i++) {\n        arr[i] = tmp[i].value;\n    }\n}\n/**\n * @param {Array<*>} arr The array to search in.\n * @param {Function} func Comparison function.\n * @return {number} Return index.\n */\nexport function findIndex(arr, func) {\n    var index;\n    var found = !arr.every(function (el, idx) {\n        index = idx;\n        return !func(el, idx, arr);\n    });\n    return found ? index : -1;\n}\n/**\n * @param {Array<*>} arr The array to test.\n * @param {Function=} opt_func Comparison function.\n * @param {boolean=} opt_strict Strictly sorted (default false).\n * @return {boolean} Return index.\n */\nexport function isSorted(arr, opt_func, opt_strict) {\n    var compare = opt_func || numberSafeCompareFunction;\n    return arr.every(function (currentVal, index) {\n        if (index === 0) {\n            return true;\n        }\n        var res = compare(arr[index - 1], currentVal);\n        return !(res > 0 || (opt_strict && res === 0));\n    });\n}\n//# sourceMappingURL=array.js.map","/**\n * @module ol/coordinate\n */\nimport { getWidth } from './extent.js';\nimport { modulo } from './math.js';\nimport { padNumber } from './string.js';\n/**\n * An array of numbers representing an xy coordinate. Example: `[16, 48]`.\n * @typedef {Array<number>} Coordinate\n * @api\n */\n/**\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\n * transforms it into a `{string}`.\n *\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\n * @api\n */\n/**\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {add} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     add(coord, [-2, 4]);\n *     // coord is now [5.85, 51.983333]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {Coordinate} delta Delta.\n * @return {Coordinate} The input coordinate adjusted by\n * the given delta.\n * @api\n */\nexport function add(coordinate, delta) {\n    coordinate[0] += +delta[0];\n    coordinate[1] += +delta[1];\n    return coordinate;\n}\n/**\n * Calculates the point closest to the passed coordinate on the passed circle.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\n * @return {Coordinate} Closest point on the circumference.\n */\nexport function closestOnCircle(coordinate, circle) {\n    var r = circle.getRadius();\n    var center = circle.getCenter();\n    var x0 = center[0];\n    var y0 = center[1];\n    var x1 = coordinate[0];\n    var y1 = coordinate[1];\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    if (dx === 0 && dy === 0) {\n        dx = 1;\n    }\n    var d = Math.sqrt(dx * dx + dy * dy);\n    var x = x0 + (r * dx) / d;\n    var y = y0 + (r * dy) / d;\n    return [x, y];\n}\n/**\n * Calculates the point closest to the passed coordinate on the passed segment.\n * This is the foot of the perpendicular of the coordinate to the segment when\n * the foot is on the segment, or the closest segment coordinate when the foot\n * is outside the segment.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {Array<Coordinate>} segment The two coordinates\n * of the segment.\n * @return {Coordinate} The foot of the perpendicular of\n * the coordinate to the segment.\n */\nexport function closestOnSegment(coordinate, segment) {\n    var x0 = coordinate[0];\n    var y0 = coordinate[1];\n    var start = segment[0];\n    var end = segment[1];\n    var x1 = start[0];\n    var y1 = start[1];\n    var x2 = end[0];\n    var y2 = end[1];\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    var along = dx === 0 && dy === 0\n        ? 0\n        : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n    var x, y;\n    if (along <= 0) {\n        x = x1;\n        y = y1;\n    }\n    else if (along >= 1) {\n        x = x2;\n        y = y2;\n    }\n    else {\n        x = x1 + along * dx;\n        y = y1 + along * dy;\n    }\n    return [x, y];\n}\n/**\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\n * used to format\n * a {Coordinate} to a string.\n *\n * Example without specifying the fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var stringifyFunc = createStringXY();\n *     var out = stringifyFunc(coord);\n *     // out is now '8, 48'\n *\n * Example with explicitly specifying 2 fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var stringifyFunc = createStringXY(2);\n *     var out = stringifyFunc(coord);\n *     // out is now '7.85, 47.98'\n *\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {CoordinateFormat} Coordinate format.\n * @api\n */\nexport function createStringXY(opt_fractionDigits) {\n    return (\n    /**\n     * @param {Coordinate} coordinate Coordinate.\n     * @return {string} String XY.\n     */\n    function (coordinate) {\n        return toStringXY(coordinate, opt_fractionDigits);\n    });\n}\n/**\n * @param {string} hemispheres Hemispheres.\n * @param {number} degrees Degrees.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} String.\n */\nexport function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {\n    var normalizedDegrees = modulo(degrees + 180, 360) - 180;\n    var x = Math.abs(3600 * normalizedDegrees);\n    var dflPrecision = opt_fractionDigits || 0;\n    var precision = Math.pow(10, dflPrecision);\n    var deg = Math.floor(x / 3600);\n    var min = Math.floor((x - deg * 3600) / 60);\n    var sec = x - deg * 3600 - min * 60;\n    sec = Math.ceil(sec * precision) / precision;\n    if (sec >= 60) {\n        sec = 0;\n        min += 1;\n    }\n    if (min >= 60) {\n        min = 0;\n        deg += 1;\n    }\n    return (deg +\n        '\\u00b0 ' +\n        padNumber(min, 2) +\n        '\\u2032 ' +\n        padNumber(sec, 2, dflPrecision) +\n        '\\u2033' +\n        (normalizedDegrees == 0\n            ? ''\n            : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0)));\n}\n/**\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\n * using the given string template. The strings `{x}` and `{y}` in the template\n * will be replaced with the first and second coordinate values respectively.\n *\n * Example without specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var template = 'Coordinate is ({x}|{y}).';\n *     var out = format(coord, template);\n *     // out is now 'Coordinate is (8|48).'\n *\n * Example explicitly specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var template = 'Coordinate is ({x}|{y}).';\n *     var out = format(coord, template, 2);\n *     // out is now 'Coordinate is (7.85|47.98).'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {string} template A template string with `{x}` and `{y}` placeholders\n *     that will be replaced by first and second coordinate values.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Formatted coordinate.\n * @api\n */\nexport function format(coordinate, template, opt_fractionDigits) {\n    if (coordinate) {\n        return template\n            .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))\n            .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));\n    }\n    else {\n        return '';\n    }\n}\n/**\n * @param {Coordinate} coordinate1 First coordinate.\n * @param {Coordinate} coordinate2 Second coordinate.\n * @return {boolean} The two coordinates are equal.\n */\nexport function equals(coordinate1, coordinate2) {\n    var equals = true;\n    for (var i = coordinate1.length - 1; i >= 0; --i) {\n        if (coordinate1[i] != coordinate2[i]) {\n            equals = false;\n            break;\n        }\n    }\n    return equals;\n}\n/**\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n * returned by the function.\n *\n * Example:\n *\n *     import {rotate} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var rotateRadians = Math.PI / 2; // 90 degrees\n *     rotate(coord, rotateRadians);\n *     // coord is now [-47.983333, 7.85]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} angle Angle in radian.\n * @return {Coordinate} Coordinate.\n * @api\n */\nexport function rotate(coordinate, angle) {\n    var cosAngle = Math.cos(angle);\n    var sinAngle = Math.sin(angle);\n    var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n    var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n    coordinate[0] = x;\n    coordinate[1] = y;\n    return coordinate;\n}\n/**\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {scale as scaleCoordinate} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var scale = 1.2;\n *     scaleCoordinate(coord, scale);\n *     // coord is now [9.42, 57.5799996]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} scale Scale factor.\n * @return {Coordinate} Coordinate.\n */\nexport function scale(coordinate, scale) {\n    coordinate[0] *= scale;\n    coordinate[1] *= scale;\n    return coordinate;\n}\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Squared distance between coord1 and coord2.\n */\nexport function squaredDistance(coord1, coord2) {\n    var dx = coord1[0] - coord2[0];\n    var dy = coord1[1] - coord2[1];\n    return dx * dx + dy * dy;\n}\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Distance between coord1 and coord2.\n */\nexport function distance(coord1, coord2) {\n    return Math.sqrt(squaredDistance(coord1, coord2));\n}\n/**\n * Calculate the squared distance from a coordinate to a line segment.\n *\n * @param {Coordinate} coordinate Coordinate of the point.\n * @param {Array<Coordinate>} segment Line segment (2\n * coordinates).\n * @return {number} Squared distance from the point to the line segment.\n */\nexport function squaredDistanceToSegment(coordinate, segment) {\n    return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\n}\n/**\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\n * seconds.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringHDMS} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringHDMS(coord);\n *     // out is now '47 58 60 N 7 50 60 E'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringHDMS} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringHDMS(coord, 1);\n *     // out is now '47 58 60.0 N 7 50 60.0 E'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Hemisphere, degrees, minutes and seconds.\n * @api\n */\nexport function toStringHDMS(coordinate, opt_fractionDigits) {\n    if (coordinate) {\n        return (degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) +\n            ' ' +\n            degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits));\n    }\n    else {\n        return '';\n    }\n}\n/**\n * Format a coordinate as a comma delimited string.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringXY(coord);\n *     // out is now '8, 48'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringXY(coord, 1);\n *     // out is now '7.8, 48.0'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} XY.\n * @api\n */\nexport function toStringXY(coordinate, opt_fractionDigits) {\n    return format(coordinate, '{x}, {y}', opt_fractionDigits);\n}\n/**\n * Modifies the provided coordinate in-place to be within the real world\n * extent. The lower projection extent boundary is inclusive, the upper one\n * exclusive.\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {Coordinate} The coordinate within the real world extent.\n */\nexport function wrapX(coordinate, projection) {\n    if (projection.canWrapX()) {\n        var worldWidth = getWidth(projection.getExtent());\n        var worldsAway = getWorldsAway(coordinate, projection, worldWidth);\n        if (worldsAway) {\n            coordinate[0] -= worldsAway * worldWidth;\n        }\n    }\n    return coordinate;\n}\n/**\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {number=} opt_sourceExtentWidth Width of the source extent.\n * @return {number} Offset in world widths.\n */\nexport function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {\n    var projectionExtent = projection.getExtent();\n    var worldsAway = 0;\n    if (projection.canWrapX() &&\n        (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {\n        var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);\n        worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);\n    }\n    return worldsAway;\n}\n//# sourceMappingURL=coordinate.js.map","/**\n * @module ol/easing\n */\n/**\n * Start slow and speed up.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function easeIn(t) {\n    return Math.pow(t, 3);\n}\n/**\n * Start fast and slow down.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function easeOut(t) {\n    return 1 - easeIn(1 - t);\n}\n/**\n * Start slow, speed up, and then slow down again.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function inAndOut(t) {\n    return 3 * t * t - 2 * t * t * t;\n}\n/**\n * Maintain a constant speed over time.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function linear(t) {\n    return t;\n}\n/**\n * Start slow, speed up, and at the very end slow down again.  This has the\n * same general behavior as {@link module:ol/easing~inAndOut}, but the final\n * slowdown is delayed.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nexport function upAndDown(t) {\n    if (t < 0.5) {\n        return inAndOut(2 * t);\n    }\n    else {\n        return 1 - inAndOut(2 * (t - 0.5));\n    }\n}\n//# sourceMappingURL=easing.js.map","/**\n * @module ol/css\n */\n/**\n * @typedef {Object} FontParameters\n * @property {string} style\n * @property {string} variant\n * @property {string} weight\n * @property {string} size\n * @property {string} lineHeight\n * @property {string} family\n * @property {Array<string>} families\n */\n/**\n * The CSS class for hidden feature.\n *\n * @const\n * @type {string}\n */\nexport var CLASS_HIDDEN = 'ol-hidden';\n/**\n * The CSS class that we'll give the DOM elements to have them selectable.\n *\n * @const\n * @type {string}\n */\nexport var CLASS_SELECTABLE = 'ol-selectable';\n/**\n * The CSS class that we'll give the DOM elements to have them unselectable.\n *\n * @const\n * @type {string}\n */\nexport var CLASS_UNSELECTABLE = 'ol-unselectable';\n/**\n * The CSS class for unsupported feature.\n *\n * @const\n * @type {string}\n */\nexport var CLASS_UNSUPPORTED = 'ol-unsupported';\n/**\n * The CSS class for controls.\n *\n * @const\n * @type {string}\n */\nexport var CLASS_CONTROL = 'ol-control';\n/**\n * The CSS class that we'll give the DOM elements that are collapsed, i.e.\n * to those elements which usually can be expanded.\n *\n * @const\n * @type {string}\n */\nexport var CLASS_COLLAPSED = 'ol-collapsed';\n/**\n * From http://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font\n * @type {RegExp}\n */\nvar fontRegEx = new RegExp([\n    '^\\\\s*(?=(?:(?:[-a-z]+\\\\s*){0,2}(italic|oblique))?)',\n    '(?=(?:(?:[-a-z]+\\\\s*){0,2}(small-caps))?)',\n    '(?=(?:(?:[-a-z]+\\\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',\n    '(?:(?:normal|\\\\1|\\\\2|\\\\3)\\\\s*){0,3}((?:xx?-)?',\n    '(?:small|large)|medium|smaller|larger|[\\\\.\\\\d]+(?:\\\\%|in|[cem]m|ex|p[ctx]))',\n    '(?:\\\\s*\\\\/\\\\s*(normal|[\\\\.\\\\d]+(?:\\\\%|in|[cem]m|ex|p[ctx])?))',\n    '?\\\\s*([-,\\\\\"\\\\\\'\\\\sa-z]+?)\\\\s*$',\n].join(''), 'i');\nvar fontRegExMatchIndex = [\n    'style',\n    'variant',\n    'weight',\n    'size',\n    'lineHeight',\n    'family',\n];\n/**\n * Get the list of font families from a font spec.  Note that this doesn't work\n * for font families that have commas in them.\n * @param {string} fontSpec The CSS font property.\n * @return {FontParameters} The font parameters (or null if the input spec is invalid).\n */\nexport var getFontParameters = function (fontSpec) {\n    var match = fontSpec.match(fontRegEx);\n    if (!match) {\n        return null;\n    }\n    var style = /** @type {FontParameters} */ ({\n        lineHeight: 'normal',\n        size: '1.2em',\n        style: 'normal',\n        weight: 'normal',\n        variant: 'normal',\n    });\n    for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {\n        var value = match[i + 1];\n        if (value !== undefined) {\n            style[fontRegExMatchIndex[i]] = value;\n        }\n    }\n    style.families = style.family.split(/,\\s?/);\n    return style;\n};\n//# sourceMappingURL=css.js.map","/**\n * @module ol/events/Event\n */\n/**\n * @classdesc\n * Stripped down implementation of the W3C DOM Level 2 Event interface.\n * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.\n *\n * This implementation only provides `type` and `target` properties, and\n * `stopPropagation` and `preventDefault` methods. It is meant as base class\n * for higher level events defined in the library, and works with\n * {@link module:ol/events/Target~Target}.\n */\nvar BaseEvent = /** @class */ (function () {\n    /**\n     * @param {string} type Type.\n     */\n    function BaseEvent(type) {\n        /**\n         * @type {boolean}\n         */\n        this.propagationStopped;\n        /**\n         * The event type.\n         * @type {string}\n         * @api\n         */\n        this.type = type;\n        /**\n         * The event target.\n         * @type {Object}\n         * @api\n         */\n        this.target = null;\n    }\n    /**\n     * Stop event propagation.\n     * @api\n     */\n    BaseEvent.prototype.preventDefault = function () {\n        this.propagationStopped = true;\n    };\n    /**\n     * Stop event propagation.\n     * @api\n     */\n    BaseEvent.prototype.stopPropagation = function () {\n        this.propagationStopped = true;\n    };\n    return BaseEvent;\n}());\n/**\n * @param {Event|import(\"./Event.js\").default} evt Event\n */\nexport function stopPropagation(evt) {\n    evt.stopPropagation();\n}\n/**\n * @param {Event|import(\"./Event.js\").default} evt Event\n */\nexport function preventDefault(evt) {\n    evt.preventDefault();\n}\nexport default BaseEvent;\n//# sourceMappingURL=Event.js.map","/**\n * @module ol/geom/GeometryType\n */\n/**\n * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, `'Circle'`.\n * @enum {string}\n */\nexport default {\n    POINT: 'Point',\n    LINE_STRING: 'LineString',\n    LINEAR_RING: 'LinearRing',\n    POLYGON: 'Polygon',\n    MULTI_POINT: 'MultiPoint',\n    MULTI_LINE_STRING: 'MultiLineString',\n    MULTI_POLYGON: 'MultiPolygon',\n    GEOMETRY_COLLECTION: 'GeometryCollection',\n    CIRCLE: 'Circle',\n};\n//# sourceMappingURL=GeometryType.js.map"],"sourceRoot":""}